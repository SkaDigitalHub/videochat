<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ChatApp - Real-Time Messaging</title>
  <!-- Add Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Add Toast Notification CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
  <style>
    /* Modern Chat App UI */
    :root {
      --primary-color: #0084ff;
      --secondary-color: #f0f2f5;
      --sidebar-bg: #182533;
      --chat-bg: #0d1418;
      --card-bg: #1e2a38;
      --message-sent: #0084ff;
      --message-received: #2d3438;
      --text-primary: #e4e6eb;
      --text-secondary: #a0a4a8;
      --border-color: #3e4042;
      --hover-color: #2a2f32;
      --online-status: #31a24c;
      --notification-color: #f02849;
      --warning-color: #ff9500;
      --request-color: #5856d6;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--chat-bg);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
    }

    /* Main App Container */
    .app-container {
      display: flex;
      height: 100vh;
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Sidebar */
    .sidebar {
      width: 80px;
      background: var(--sidebar-bg);
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--border-color);
      transition: width 0.3s ease;
      overflow: hidden;
      flex-shrink: 0;
    }

    .sidebar.expanded {
      width: 250px;
    }

    /* Profile Section */
    .profile-section {
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      gap: 15px;
      min-height: 90px;
    }

    .profile-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 20px;
      color: white;
      cursor: pointer;
      flex-shrink: 0;
    }

    .profile-info {
      display: none;
    }

    .sidebar.expanded .profile-info {
      display: block;
    }

    .profile-name {
      font-weight: 600;
      font-size: 16px;
    }

    .profile-status {
      font-size: 12px;
      color: var(--online-status);
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--online-status);
    }

    /* Settings Menu */
    .settings-menu {
      padding: 20px;
      display: none;
      flex-direction: column;
      gap: 10px;
    }

    .sidebar.expanded .settings-menu {
      display: flex;
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .menu-item:hover {
      background: var(--hover-color);
    }

    .menu-item.active {
      background: var(--primary-color);
    }

    .menu-item i {
      width: 20px;
      text-align: center;
      font-size: 18px;
    }

    .menu-item span {
      font-size: 14px;
    }

    .menu-item.has-notifications::after {
      content: '';
      width: 8px;
      height: 8px;
      background: var(--notification-color);
      border-radius: 50%;
      margin-left: auto;
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--chat-bg);
      overflow: hidden;
    }

    /* Top Header */
    .top-header {
      padding: 15px 20px;
      border-bottom: 1px solid var(--border-color);
      background: var(--sidebar-bg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .header-title {
      font-size: 20px;
      font-weight: 600;
    }

    .header-subtitle {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .header-actions {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .header-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 18px;
      cursor: pointer;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, color 0.2s;
    }

    .header-btn:hover {
      background: var(--hover-color);
      color: var(--primary-color);
    }

    /* Cards Container */
    .cards-container {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 15px;
      align-content: start;
    }

    /* Chat Card */
    .chat-card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      border: 1px solid transparent;
      border-left: 4px solid var(--primary-color);
      position: relative;
    }

    .chat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
      border-color: var(--border-color);
    }

    .chat-card.active {
      border-left-color: var(--online-status);
      background: rgba(0, 132, 255, 0.1);
    }

    .chat-card.request-card {
      border-left-color: var(--request-color);
    }

    .chat-card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .chat-card-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 18px;
      color: white;
      flex-shrink: 0;
    }

    .chat-card-info {
      flex: 1;
      min-width: 0;
    }

    .chat-card-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .chat-card-name {
      font-weight: 600;
      font-size: 16px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chat-card-time {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .chat-card-status {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .chat-card-preview {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .chat-card-badge {
      position: absolute;
      top: 15px;
      right: 15px;
      background: var(--notification-color);
      color: white;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 10px;
      display: none;
    }

    .chat-card.has-unread .chat-card-badge {
      display: block;
    }

    .request-indicator {
      position: absolute;
      top: 15px;
      right: 15px;
      background: var(--request-color);
      color: white;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 10px;
      display: none;
    }

    .chat-card.request-card .request-indicator {
      display: block;
    }

    .chat-card-actions {
      display: flex;
      gap: 8px;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card-btn {
      flex: 1;
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .card-btn.accept {
      background: var(--online-status);
      color: white;
    }

    .card-btn.decline {
      background: var(--notification-color);
      color: white;
    }

    .card-btn.block {
      background: var(--border-color);
      color: var(--text-primary);
    }

    .card-btn:hover {
      opacity: 0.9;
    }

    /* Chat View */
    .chat-view {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--chat-bg);
      z-index: 100;
      display: none;
      flex-direction: column;
    }

    .chat-view.active {
      display: flex;
    }

    .chat-view-header {
      padding: 15px 20px;
      border-bottom: 1px solid var(--border-color);
      background: var(--sidebar-bg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    .chat-view-back {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
      padding: 10px;
      margin-right: 15px;
    }

    .chat-view-back:hover {
      color: var(--primary-color);
    }

    .chat-view-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .chat-view-title {
      font-weight: 600;
      font-size: 18px;
    }

    .chat-view-subtitle {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Messages Container */
    .messages-container {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      background: url('data:image/svg+xml,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><pattern id="pattern" x="0" y="0" width="40" height="40" patternUnits="userSpaceOnUse"><circle cx="20" cy="20" r="1" fill="%23333" opacity="0.2"/></pattern><rect width="100%" height="100%" fill="url(%23pattern)"/></svg>');
    }

    /* Request View */
    .request-view {
      max-width: 500px;
      margin: 40px auto;
      text-align: center;
      padding: 30px;
      background: var(--sidebar-bg);
      border-radius: 15px;
      border: 1px solid var(--border-color);
    }

    .request-avatar-large {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, #5856d6 0%, #7a79e0 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 32px;
      color: white;
      margin: 0 auto 20px;
    }

    .request-title {
      font-size: 24px;
      margin-bottom: 10px;
    }

    .request-message {
      background: var(--message-received);
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      text-align: left;
      font-style: italic;
    }

    .request-meta {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 5px;
    }

    .request-actions-large {
      display: flex;
      gap: 10px;
      margin-top: 30px;
    }

    .request-btn-large {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .request-btn-large:hover {
      transform: translateY(-2px);
    }

    .request-btn-large.accept {
      background: var(--online-status);
      color: white;
    }

    .request-btn-large.decline {
      background: var(--notification-color);
      color: white;
    }

    .request-btn-large.block {
      background: var(--border-color);
      color: var(--text-primary);
    }

    /* Date Separator */
    .date-separator {
      text-align: center;
      margin: 10px 0;
      position: relative;
    }

    .date-separator span {
      background: var(--sidebar-bg);
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Message Bubbles */
    .message {
      max-width: 65%;
      padding: 10px 15px;
      border-radius: 18px;
      position: relative;
      word-wrap: break-word;
      line-height: 1.4;
      animation: messageAppear 0.3s ease;
    }

    @keyframes messageAppear {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.sent {
      align-self: flex-end;
      background: var(--message-sent);
      color: white;
      border-bottom-right-radius: 5px;
    }

    .message.received {
      align-self: flex-start;
      background: var(--message-received);
      color: var(--text-primary);
      border-bottom-left-radius: 5px;
    }

    .message-sender {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--primary-color);
    }

    .message-time {
      font-size: 11px;
      text-align: right;
      margin-top: 5px;
      opacity: 0.8;
    }

    /* Input Area */
    .input-area {
      padding: 20px;
      border-top: 1px solid var(--border-color);
      background: var(--sidebar-bg);
      display: flex;
      gap: 15px;
      align-items: center;
      flex-shrink: 0;
    }

    .message-input {
      flex: 1;
      background: var(--message-received);
      border: none;
      border-radius: 20px;
      padding: 12px 20px;
      color: var(--text-primary);
      font-size: 14px;
      outline: none;
    }

    .message-input::placeholder {
      color: var(--text-secondary);
    }

    .send-btn {
      background: var(--primary-color);
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s;
    }

    .send-btn:hover {
      background: #0073e6;
    }

    .send-btn:disabled {
      background: var(--border-color);
      cursor: not-allowed;
    }

    /* Profile Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      background: var(--sidebar-bg);
      border-radius: 12px;
      padding: 30px;
      width: 90%;
      max-width: 400px;
      animation: modalAppear 0.3s ease;
    }

    @keyframes modalAppear {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .modal-title {
      margin-bottom: 20px;
      text-align: center;
      font-size: 24px;
    }

    .input-group {
      margin-bottom: 20px;
    }

    .input-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-secondary);
    }

    .modal-input {
      width: 100%;
      padding: 12px;
      background: var(--message-received);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
      outline: none;
    }

    .modal-input:focus {
      border-color: var(--primary-color);
    }

    .modal-actions {
      display: flex;
      gap: 10px;
      margin-top: 30px;
    }

    .modal-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .modal-btn.primary {
      background: var(--primary-color);
      color: white;
    }

    .modal-btn.secondary {
      background: var(--message-received);
      color: var(--text-primary);
    }

    .modal-btn:hover {
      opacity: 0.9;
    }

    /* Privacy Settings Modal */
    .privacy-options {
      margin-top: 20px;
    }

    .privacy-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: background 0.2s;
      border: 1px solid var(--border-color);
    }

    .privacy-option:hover {
      background: var(--hover-color);
    }

    .privacy-option.selected {
      border-color: var(--primary-color);
      background: rgba(0, 132, 255, 0.1);
    }

    .privacy-option input[type="radio"] {
      display: none;
    }

    .option-info {
      flex: 1;
      margin-right: 15px;
    }

    .option-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .option-description {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Blocked Users Modal */
    .blocked-users-list {
      max-height: 300px;
      overflow-y: auto;
      margin-top: 15px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
    }

    .blocked-user-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 5px;
      background: var(--message-received);
    }

    .blocked-user-name {
      font-weight: 500;
    }

    .unblock-btn {
      background: var(--notification-color);
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
    }

    .unblock-btn:hover {
      opacity: 0.9;
    }

    /* Add Contact Modal */
    #add-contact-modal .modal-content {
      max-width: 350px;
    }

    .contact-list {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 10px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
    }

    .contact-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .contact-item:hover {
      background: var(--hover-color);
    }

    .contact-item.selected {
      background: var(--primary-color);
    }

    .contact-name {
      font-weight: 500;
    }

    .contact-status {
      font-size: 11px;
      color: var(--text-secondary);
    }

    /* Task Bar Notification */
    .taskbar-notification {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: var(--notification-color);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      display: none;
      align-items: center;
      gap: 10px;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .taskbar-notification.active {
      display: flex;
    }

    /* Request Notification */
    .request-notification {
      position: fixed;
      bottom: 70px;
      right: 10px;
      background: var(--request-color);
      color: white;
      padding: 15px;
      border-radius: 8px;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.3s ease;
      max-width: 300px;
      display: none;
    }

    .request-notification.active {
      display: block;
    }

    .request-notification h4 {
      margin-bottom: 5px;
    }

    .request-notification p {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 10px;
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }

    /* Add to your existing CSS, anywhere in the <style> section */

/* Message Actions - Hover menu */
.message-actions {
  position: absolute;
  right: 10px;
  top: -30px;
  background: var(--sidebar-bg);
  border-radius: 8px;
  padding: 5px;
  display: flex;
  gap: 5px;
  opacity: 0;
  transform: translateY(10px);
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  z-index: 10;
}

.message:hover .message-actions {
  opacity: 1;
  transform: translateY(0);
}

.message-action-btn {
  background: var(--card-bg);
  border: none;
  color: var(--text-primary);
  width: 20px;
  height: 20px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
}

.message-action-btn:hover {
  background: var(--primary-color);
  color: white;
  transform: scale(1.1);
}

/* ========== ENHANCED REPLY THREAD STYLING ========== */

/* Reply Preview in Input Area */
.reply-preview {
  background: linear-gradient(135deg, rgba(0, 132, 255, 0.15) 0%, rgba(76, 0, 255, 0.1) 100%);
  border-left: 4px solid var(--primary-color);
  border-radius: 12px;
  padding: 12px 16px;
  margin-bottom: 12px;
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(10px);
  animation: slideDown 0.3s ease;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.reply-preview::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: linear-gradient(to bottom, var(--primary-color), #764ba2);
}

.reply-preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(0, 132, 255, 0.2);
}

.reply-preview-sender {
  font-weight: 700;
  font-size: 13px;
  color: var(--primary-color);
  display: flex;
  align-items: center;
  gap: 6px;
}

.reply-preview-sender::before {
  content: '‚Ü©Ô∏è';
  font-size: 12px;
  opacity: 0.8;
}

.reply-preview-close {
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: all 0.2s ease;
}

.reply-preview-close:hover {
  background: rgba(255, 255, 255, 0.2);
  color: var(--notification-color);
  transform: rotate(90deg);
}

.reply-preview-text {
  color: var(--text-primary);
  font-size: 13px;
  line-height: 1.4;
  padding-left: 20px;
  position: relative;
  max-height: 60px;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  line-clamp: 3;
  -webkit-box-orient: vertical;
}

.reply-preview-text::before {
  content: '"';
  position: absolute;
  left: 8px;
  top: 0;
  font-size: 16px;
  color: var(--primary-color);
  opacity: 0.5;
}

.reply-preview-text::after {
  content: '"';
  position: absolute;
  right: 0;
  bottom: 0;
  font-size: 16px;
  color: var(--primary-color);
  opacity: 0.5;
}

/* Reply Indicator in Messages */
.reply-to-indicator {
  background: rgba(0, 132, 255, 0.1);
  border-left: 3px solid var(--primary-color);
  border-radius: 8px;
  padding: 8px 12px;
  margin-bottom: 8px;
  font-size: 11px;
  color: var(--primary-color);
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.reply-to-indicator::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
  transform: translateX(-100%);
}

.reply-to-indicator:hover {
  background: rgba(0, 132, 255, 0.15);
  transform: translateX(2px);
}

.reply-to-indicator:hover::before {
  animation: shine 1s ease;
}

@keyframes shine {
  100% {
    transform: translateX(100%);
  }
}

.reply-to-indicator i {
  font-size: 10px;
  color: var(--primary-color);
}

.reply-to-indicator .reply-sender-name {
  font-weight: 700;
  color: var(--primary-color);
  margin-right: 4px;
}

.reply-to-indicator .reply-preview-text {
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-style: italic;
  opacity: 0.9;
  padding-left: 0;
  max-height: none;
}

.reply-to-indicator .reply-preview-text::before,
.reply-to-indicator .reply-preview-text::after {
  display: none;
}

/* Clickable reply indicator */
.reply-to-indicator.clickable {
  cursor: pointer;
  transition: all 0.2s ease;
}

.reply-to-indicator.clickable:hover {
  background: rgba(0, 132, 255, 0.2);
  transform: translateX(4px);
  box-shadow: 0 2px 8px rgba(0, 132, 255, 0.2);
}

.reply-to-indicator.clickable:active {
  transform: translateX(2px);
}

/* Non-clickable reply indicator */
.reply-to-indicator:not(.clickable) {
  cursor: default;
  opacity: 0.8;
}

.reply-to-indicator:not(.clickable) .reply-sender-name {
  opacity: 0.7;
}

.reply-to-indicator:not(.clickable)::before {
  animation: none;
}

.reply-to-indicator:not(.clickable):hover {
  background: rgba(0, 132, 255, 0.1);
  transform: none;
}

/* Message with Reply - Enhanced Styling */
.message.has-reply {
  margin-top: 5px;
}

.message.has-reply .message-text {
  margin-top: 4px;
}

/* Grouped Replies */
.reply-thread {
  border-left: 2px solid rgba(0, 132, 255, 0.3);
  margin-left: 10px;
  padding-left: 15px;
  position: relative;
}

.reply-thread::before {
  content: '';
  position: absolute;
  left: -2px;
  top: 0;
  width: 2px;
  height: 100%;
  background: linear-gradient(to bottom, transparent, var(--primary-color), transparent);
}

/* Reply Animation */
@keyframes highlightReply {
  0% {
    background: rgba(0, 132, 255, 0.3);
  }
  100% {
    background: transparent;
  }
}

.message.reply-highlight {
  animation: highlightReply 2s ease;
}

/* Responsive Reply Styles */
@media (max-width: 768px) {
  .reply-preview {
    padding: 10px 12px;
    margin-bottom: 10px;
  }
  
  .reply-to-indicator {
    padding: 6px 10px;
    font-size: 10px;
  }
  
  .reply-preview-text {
    -webkit-line-clamp: 2;
    line-clamp: 2;
    max-height: 40px;
  }
}

/* Dark mode enhancement for replies */
.message.received .reply-to-indicator {
  background: rgba(0, 132, 255, 0.08);
  border-left-color: rgba(0, 132, 255, 0.6);
}

.message.sent .reply-to-indicator {
  background: rgba(255, 255, 255, 0.1);
  border-left-color: rgba(255, 255, 255, 0.6);
}

/* Reply thread connector lines */
.reply-thread-connector {
  position: absolute;
  left: -15px;
  top: 0;
  width: 15px;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.reply-thread-connector::before {
  content: '';
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--primary-color);
  opacity: 0.5;
}

.reply-thread-connector::after {
  content: '';
  flex: 1;
  width: 2px;
  background: linear-gradient(to bottom, var(--primary-color), transparent);
  opacity: 0.3;
}

/* Forward Modal */
.forward-modal-content {
  max-width: 500px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}

.forward-search {
  margin-bottom: 15px;
}

.forward-search-input {
  width: 100%;
  padding: 10px 15px;
  background: var(--message-received);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-primary);
  font-size: 14px;
}

.forward-chats-list {
  flex: 1;
  overflow-y: auto;
  max-height: 400px;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 10px;
}

.forward-chat-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
  margin-bottom: 5px;
}

.forward-chat-item:hover {
  background: var(--hover-color);
}

.forward-chat-item.selected {
  background: rgba(0, 132, 255, 0.1);
  border: 1px solid var(--primary-color);
}

.forward-chat-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 16px;
  color: white;
  flex-shrink: 0;
}

.forward-chat-info {
  flex: 1;
  min-width: 0;
}

.forward-chat-name {
  font-weight: 600;
  font-size: 14px;
}

.forward-chat-type {
  font-size: 11px;
  color: var(--text-secondary);
}

.forward-actions {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

/* Add to your CSS if not already there */
#cancel-reply-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 14px;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.2s;
}

#cancel-reply-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  color: var(--notification-color);
}

/* Clickable phone numbers and URLs in messages */
.message-text {
  word-wrap: break-word;
  white-space: pre-wrap;
}

.clickable-link {
  color: #0084ff;
  text-decoration: underline;
  cursor: pointer;
  transition: all 0.2s ease;
}

.clickable-link:hover {
  color: #0066cc;
  text-decoration: none;
}

.clickable-phone {
  color: #31a24c;
  text-decoration: underline;
  cursor: pointer;
  transition: all 0.2s ease;
}

.clickable-phone:hover {
  color: #258b3d;
  text-decoration: none;
}

/* For sent messages */
.message.sent .clickable-link {
  color: #ffffff;
  opacity: 0.9;
}

.message.sent .clickable-phone {
  color: #ffffff;
  opacity: 0.9;
}

.message.sent .clickable-link:hover,
.message.sent .clickable-phone:hover {
  opacity: 1;
}

/* URL preview tooltip */
.url-tooltip {
  position: absolute;
  background: var(--sidebar-bg);
  color: var(--text-primary);
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border-color);
  max-width: 300px;
  word-wrap: break-word;
  display: none;
}

.url-tooltip.show {
  display: block;
  animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-5px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Phone call confirmation */
.phone-call-modal {
  text-align: center;
}

.phone-call-modal i {
  font-size: 30px;
  color: #31a24c;
  margin-bottom: 15px;
}

.phone-number-display {
  font-size: 18px;
  font-weight: 600;
  margin: 15px 0;
  color: var(--text-primary);
  background: var(--message-received);
  padding: 10px;
  border-radius: 6px;
  letter-spacing: 1px;
}

/* External link warning */
.external-link-warning {
  background: rgba(255, 149, 0, 0.1);
  border: 1px solid var(--warning-color);
  border-radius: 8px;
  padding: 10px;
  margin: 10px 0;
  font-size: 12px;
}

.external-link-warning i {
  color: var(--warning-color);
  margin-right: 5px;
}

/* Context menu for links */
.link-context-menu {
  position: absolute;
  background: var(--sidebar-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 8px 0;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  min-width: 180px;
  display: none;
}

.link-context-menu.show {
  display: block;
  animation: fadeIn 0.2s ease;
}

.context-menu-item {
  padding: 8px 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 10px;
  transition: background 0.2s;
}

.context-menu-item:hover {
  background: var(--hover-color);
}

.context-menu-item i {
  width: 16px;
  text-align: center;
  color: var(--text-secondary);
}

.context-menu-divider {
  height: 1px;
  background: var(--border-color);
  margin: 4px 0;
}

/* ========== MESSAGE REACTIONS ========== */

/* Reaction container */
.message-reactions {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 8px;
  padding: 4px 8px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 20px;
  max-width: 250px;
  min-height: 32px;
}

/* Individual reaction */
.reaction {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 3px 8px;
  background: var(--card-bg);
  border-radius: 15px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid transparent;
  user-select: none;
}

.reaction:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.reaction.active {
  background: rgba(0, 132, 255, 0.15);
  border-color: var(--primary-color);
}

.reaction-emoji {
  font-size: 14px;
}

.reaction-count {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-secondary);
  min-width: 12px;
}

/* Sent message reactions */
.message.sent .message-reactions {
  align-self: flex-end;
  background: rgba(255, 255, 255, 0.1);
}

/* Reaction picker */
.reaction-picker {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: var(--sidebar-bg);
  border: 1px solid var(--border-color);
  border-radius: 24px;
  padding: 8px;
  display: flex;
  gap: 6px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  z-index: 100;
  opacity: 0;
  visibility: hidden;
  transition: all 0.2s ease;
  backdrop-filter: blur(10px);
}

.reaction-picker.show {
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(-5px);
}

.reaction-option {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  cursor: pointer;
  border-radius: 50%;
  transition: all 0.2s ease;
}

.reaction-option:hover {
  background: var(--hover-color);
  transform: scale(1.2);
}

/* Reaction animation */
@keyframes reactionPop {
  0% {
    transform: scale(0);
    opacity: 0;
  }
  70% {
    transform: scale(1.2);
    opacity: 1;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.reaction.added {
  animation: reactionPop 0.3s ease;
}

/* Quick reactions bar */
/* Add this to your CSS section */
.reaction-picker {
  position: absolute;
  background: var(--sidebar-bg);
  border: 1px solid var(--border-color);
  border-radius: 20px;
  padding: 8px;
  display: flex;
  gap: 6px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
}

.reaction-picker.show {
  opacity: 1;
  visibility: visible;
}

.reaction-option {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  cursor: pointer;
  border-radius: 50%;
  transition: all 0.2s ease;
}

.reaction-option:hover {
  background: var(--hover-color);
  transform: scale(1.2);
}

.quick-reactions {
  display: flex;
  gap: 4px;
  margin-top: 4px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.message:hover .quick-reactions {
  opacity: 1;
}

.quick-reaction-btn {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s ease;
}

.quick-reaction-btn:hover {
  background: var(--hover-color);
  transform: scale(1.1);
}

/* Reaction summary modal */
.reaction-details-modal .modal-content {
  max-width: 400px;
}

.reaction-detail-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 15px;
  border-bottom: 1px solid var(--border-color);
}

.reaction-detail-item:last-child {
  border-bottom: none;
}

.reaction-detail-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.reaction-detail-emoji {
  font-size: 20px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--card-bg);
  border-radius: 50%;
}

.reaction-detail-name {
  font-weight: 500;
}

.reaction-detail-time {
  font-size: 11px;
  color: var(--text-secondary);
}

/* Mobile responsive */
@media (max-width: 768px) {
  .reaction-picker {
    padding: 6px;
    gap: 4px;
  }
  
  .reaction-option {
    width: 28px;
    height: 28px;
    font-size: 16px;
  }
  
  .reaction {
    padding: 2px 6px;
    font-size: 12px;
  }
  
  .quick-reactions {
    opacity: 1; /* Always show on mobile */
  }
}

/* Dark mode adjustments */
.message.received .reaction.active {
  background: rgba(0, 132, 255, 0.1);
}

.message.sent .reaction.active {
  background: rgba(255, 255, 255, 0.15);
}

    /* Responsive Design */
    @media (max-width: 768px) {
      .sidebar {
        position: fixed;
        left: -100%;
        width: 250px;
        height: 100vh;
        z-index: 100;
        transition: left 0.3s ease;
      }
      
      .sidebar.active {
        left: 0;
      }

        /* FIX: Show sidebar content when active on mobile */
  .sidebar.active .profile-info {
    display: block;
  }
  
  .sidebar.active .settings-menu {
    display: flex;
  }
  
  /* FIX: Ensure expanded class doesn't interfere on mobile */
  .sidebar.expanded {
    width: 250px; /* Keep width */
  }
      
      .cards-container {
        grid-template-columns: 1fr;
        padding: 15px;
      }
      
      .chat-card {
        margin-bottom: 10px;
      }
      
      .header-title {
        font-size: 18px;
      }
      
      .request-actions-large {
        flex-direction: column;
      }
    }

    @media (min-width: 769px) and (max-width: 1024px) {
      .cards-container {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Loading State */
    .loading {
      opacity: 0.6;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Taskbar Notification -->
  <div id="taskbar-notification" class="taskbar-notification">
    <i class="fas fa-comment-alt"></i>
    <span id="notification-text">New message</span>
  </div>

  <!-- Request Notification -->
  <div id="request-notification" class="request-notification">
    <h4>New Message Request</h4>
    <p id="request-notification-text"></p>
    <div style="display: flex; gap: 10px;">
      <button onclick="viewMessageRequest()" style="flex:1; padding: 5px; background: white; color: var(--request-color); border: none; border-radius: 4px; cursor: pointer;">View</button>
      <button onclick="dismissRequestNotification()" style="padding: 5px; background: transparent; color: white; border: 1px solid white; border-radius: 4px; cursor: pointer;">Dismiss</button>
    </div>
  </div>

  <!-- Profile Setup Modal -->
  <div id="profile-modal" class="modal-overlay">
    <div class="modal-content">
      <h2 class="modal-title">Welcome to ChatApp</h2>
      <div class="input-group">
        <label for="profile-name">Your Name</label>
        <input type="text" id="profile-name" class="modal-input" placeholder="Enter your name" maxlength="20">
      </div>
      <div class="input-group">
        <label for="profile-status">Status</label>
        <input type="text" id="profile-status" class="modal-input" placeholder="How are you feeling?" maxlength="30">
      </div>
      <div class="modal-actions">
        <button class="modal-btn primary" onclick="saveProfile()">Start Chatting</button>
      </div>
    </div>
  </div>

  <!-- Privacy Settings Modal -->
  <div id="privacy-modal" class="modal-overlay">
    <div class="modal-content">
      <h2 class="modal-title">Privacy Settings</h2>
      <div class="privacy-options">
        <div class="privacy-option" onclick="selectPrivacyOption('everyone')">
          <div class="option-info">
            <div class="option-title">Everyone</div>
            <div class="option-description">Anyone can message you. New contacts will appear as message requests.</div>
          </div>
          <input type="radio" name="privacy" value="everyone" id="privacy-everyone">
        </div>
        
        <div class="privacy-option" onclick="selectPrivacyOption('contacts')">
          <div class="option-info">
            <div class="option-title">Contacts Only</div>
            <div class="option-description">Only people in your contacts can message you directly.</div>
          </div>
          <input type="radio" name="privacy" value="contacts" id="privacy-contacts">
        </div>
        
        <div class="privacy-option" onclick="selectPrivacyOption('nobody')">
          <div class="option-info">
            <div class="option-title">Nobody</div>
            <div class="option-description">No one can send you new message requests.</div>
          </div>
          <input type="radio" name="privacy" value="nobody" id="privacy-nobody">
        </div>
      </div>
      
      <div class="modal-actions">
        <button class="modal-btn secondary" onclick="closePrivacyModal()">Cancel</button>
        <button class="modal-btn primary" onclick="savePrivacySettings()">Save</button>
      </div>
    </div>
  </div>

  <!-- Blocked Users Modal -->
  <div id="blocked-modal" class="modal-overlay">
    <div class="modal-content">
      <h2 class="modal-title">Blocked Users</h2>
      <div class="blocked-users-list" id="blocked-users-list">
        <!-- Blocked users will be listed here -->
      </div>
      <div class="modal-actions">
        <button class="modal-btn primary" onclick="closeBlockedModal()">Close</button>
      </div>
    </div>
  </div>

<!-- Reply/Forward Modal -->
<div id="message-actions-modal" class="modal-overlay">
  <div class="modal-content forward-modal-content">
    <h2 class="modal-title" id="message-actions-title">Forward Message</h2>
    
    <!-- Message Preview -->
    <div class="reply-preview" id="forward-message-preview" style="margin-bottom: 20px;">
      <div class="reply-preview-header">
        <div class="reply-preview-sender" id="forward-preview-sender">Sender</div>
      </div>
      <div class="reply-preview-text" id="forward-preview-text">Message text...</div>
    </div>
    
    <!-- Search -->
    <div class="forward-search">
      <input type="text" class="forward-search-input" id="forward-search-input" 
             placeholder="Search chats..." onkeyup="filterForwardChats()">
    </div>
    
    <!-- Chats List -->
    <div class="forward-chats-list" id="forward-chats-list">
      <!-- Chats will be populated here -->
    </div>
    
    <!-- Actions -->
    <div class="forward-actions">
      <button class="modal-btn secondary" onclick="closeMessageActionsModal()">Cancel</button>
      <button class="modal-btn primary" onclick="sendForwardedMessage()" id="send-forward-btn" disabled>Forward</button>
    </div>
  </div>
</div>

  <!-- Add Contact Modal -->
  <div id="add-contact-modal" class="modal-overlay">
    <div class="modal-content">
      <h2 class="modal-title">Add New Contact</h2>
      <div class="input-group">
        <label for="new-contact-name">Username</label>
        <input type="text" id="new-contact-name" class="modal-input" placeholder="Enter username" maxlength="20">
      </div>
      <div class="modal-actions">
        <button class="modal-btn secondary" onclick="closeAddContactModal()">Cancel</button>
        <button class="modal-btn primary" onclick="addNewContact()">Add Contact</button>
      </div>
      
      <div style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 15px;">
        <h4 style="margin-bottom: 10px; color: var(--text-secondary);">Available Users</h4>
        <div class="contact-list" id="available-users-list">
          <!-- Available users will be listed here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Main App Container -->
  <div class="app-container">
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
      <!-- Profile Section -->
      <div class="profile-section">
        <div class="profile-avatar" id="profile-avatar" onclick="toggleSidebar()">
          <span id="avatar-initials">U</span>
        </div>
        <div class="profile-info">
          <div class="profile-name" id="profile-display-name">User</div>
          <div class="profile-status">
            <span class="status-dot"></span>
            <span id="profile-status-text">Online</span>
          </div>
        </div>
      </div>

      <!-- Settings Menu -->
      <div class="settings-menu">
        <div class="menu-item active" onclick="showSection('chats')">
          <i class="fas fa-comments"></i>
          <span>Chats</span>
        </div>
        <div class="menu-item" onclick="showSection('requests')" id="requests-menu-item">
          <i class="fas fa-question-circle"></i>
          <span>Message Requests</span>
        </div>
        <div class="menu-item" onclick="showSection('groups')">
          <i class="fas fa-users"></i>
          <span>Groups</span>
        </div>
        <div class="menu-item" onclick="showAddContactModal()">
          <i class="fas fa-user-plus"></i>
          <span>Add Contact</span>
        </div>
        <div class="menu-item" onclick="showPrivacySettings()">
          <i class="fas fa-shield-alt"></i>
          <span>Privacy</span>
        </div>
        <div class="menu-item" onclick="showBlockedUsers()">
          <i class="fas fa-ban"></i>
          <span>Blocked Users</span>
        </div>
        <div class="menu-item" onclick="showSection('profile')">
          <i class="fas fa-user"></i>
          <span>Edit Profile</span>
        </div>
        <div class="menu-item" onclick="initiateVideoCall()">
          <i class="fas fa-video"></i>
          <span>Video Call</span>
        </div>
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
      <!-- Top Header -->
      <div class="top-header">
        <div class="header-left">
          <button class="header-btn" onclick="toggleSidebar()" title="Toggle Sidebar">
            <i class="fas fa-bars"></i>
          </button>
          <div>
            <div class="header-title" id="page-title">Chats</div>
            <div class="header-subtitle" id="page-subtitle">All your conversations</div>
          </div>
        </div>
        <div class="header-actions">
          <button class="header-btn" onclick="searchChats()" title="Search">
            <i class="fas fa-search"></i>
          </button>
          <button class="header-btn" onclick="addMarkAllReadButton()" title="Refresh">
            <i class="fas fa-sync-alt"></i>
          </button>
          <button class="header-btn" onclick="showAddContactModal()" title="Add Contact">
            <i class="fas fa-user-plus"></i>
          </button>
        </div>
      </div>

      <!-- Cards Container -->
      <div class="cards-container" id="cards-container">
        <!-- Chat cards will be dynamically added here -->
        <div class="welcome-message" id="welcome-message">
          <p>Loading chats...</p>
        </div>
      </div>

      <!-- Chat View (Hidden by default) -->
      <div class="chat-view" id="chat-view">
        <!-- Chat Header -->
        <div class="chat-view-header">
          <button class="chat-view-back" onclick="closeChatView()">
            <i class="fas fa-arrow-left"></i>
          </button>
          <div class="chat-view-info">
            <div class="profile-avatar small" id="current-chat-avatar">
              <span id="current-chat-initials">G</span>
            </div>
            <div>
              <div class="chat-view-title" id="current-chat-title">Global Chat</div>
              <div class="chat-view-subtitle" id="current-chat-subtitle">Group ‚Ä¢ 8 members</div>
            </div>
          </div>
          <div class="header-actions">
            <button class="header-btn" onclick="clearChat()" title="Clear Chat">
              <i class="fas fa-trash"></i>
            </button>
            <button class="header-btn" onclick="initiateVideoCall()" title="Video Call">
              <i class="fas fa-video"></i>
            </button>
          </div>
        </div>

        <!-- Messages Container -->
        <div class="messages-container" id="messages-container">
          <!-- Messages will be dynamically added here -->
          <div class="welcome-message">
            <p>Select a chat to start messaging</p>
          </div>
        </div>

        <!-- Input Area -->
        <div class="input-area">
          <input type="text" class="message-input" id="message-input" placeholder="Type a message..." disabled>
          <button class="send-btn" id="send-btn" onclick="sendMessage()" disabled>
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Toastify JS -->
  <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
  <script>
    // Configuration
    const scriptUrl = 'https://script.google.com/macros/s/AKfycbzvMIpB50e94TqXUELT5aAPVhe4a_O_uYBl2yiaF4TbCICk5Fr61kXeJN-S3CKiZu_8/exec';
    
    // App State
    const state = {
      currentUser: null,
      currentChat: null,
      chats: {},
      users: ["Rev", "Ska", "kinaa", "Eyram", "Yayra", "Stephen", "Diana"],
      groups: ["Global Chat", "Team Project", "Friends"],
      lastMessageId: 0,
      notifications: new Set(),
      sidebarExpanded: false,
      userContacts: [],
      pendingMessages: new Set(),
      messageRequests: [],
      blockedUsers: [],
      privacySettings: {
        whoCanMessage: 'everyone',
        readReceipts: true,
        lastSeen: 'everyone'
      },
      currentSection: 'chats',
      activeRequestId: null,
      currentReply: null, // {messageId, sender, text}
      currentForwardMessage: null, // {messageId, sender, text}
      replyMode: false,
      forwardMode: false
    };

    // Reaction Configuration
const REACTIONS = {
  'üëç': { name: 'like', color: '#0084ff' },
  '‚ù§Ô∏è': { name: 'love', color: '#f02849' },
  'üòÇ': { name: 'laugh', color: '#ff9500' },
  'üòÆ': { name: 'wow', color: '#ff9500' },
  'üò¢': { name: 'sad', color: '#ff9500' },
  'üò°': { name: 'angry', color: '#ff9500' },
  'üéâ': { name: 'celebration', color: '#31a24c' },
  'üëè': { name: 'clap', color: '#0084ff' },
  'üôåüèΩ': { name: 'thanks', color: '#0084ff' },
  'üî•': { name: 'fire', color: '#ff9500' }
};

const QUICK_REACTIONS = ['üôåüèΩ', 'üëç', '‚ù§Ô∏è', 'üòÇ', 'üî•', 'üòÆ', 'üéâ'];

    // DOM Elements
    const elements = {
      // Modals
      profileModal: document.getElementById('profile-modal'),
      profileName: document.getElementById('profile-name'),
      profileStatus: document.getElementById('profile-status'),
      privacyModal: document.getElementById('privacy-modal'),
      blockedModal: document.getElementById('blocked-modal'),
      blockedUsersList: document.getElementById('blocked-users-list'),
      addContactModal: document.getElementById('add-contact-modal'),
      newContactName: document.getElementById('new-contact-name'),
      availableUsersList: document.getElementById('available-users-list'),
      
      // Notifications
      taskbarNotification: document.getElementById('taskbar-notification'),
      notificationText: document.getElementById('notification-text'),
      requestNotification: document.getElementById('request-notification'),
      requestNotificationText: document.getElementById('request-notification-text'),
      
      // Profile
      profileDisplayName: document.getElementById('profile-display-name'),
      profileStatusText: document.getElementById('profile-status-text'),
      avatarInitials: document.getElementById('avatar-initials'),
      
      // Sidebar
      sidebar: document.getElementById('sidebar'),
      requestsMenuItem: document.getElementById('requests-menu-item'),
      
      // Main content
      pageTitle: document.getElementById('page-title'),
      pageSubtitle: document.getElementById('page-subtitle'),
      cardsContainer: document.getElementById('cards-container'),
      welcomeMessage: document.getElementById('welcome-message'),
      
      // Chat view
      chatView: document.getElementById('chat-view'),
      currentChatAvatar: document.getElementById('current-chat-avatar'),
      currentChatInitials: document.getElementById('current-chat-initials'),
      currentChatTitle: document.getElementById('current-chat-title'),
      currentChatSubtitle: document.getElementById('current-chat-subtitle'),
      messagesContainer: document.getElementById('messages-container'),
      messageInput: document.getElementById('message-input'),
      sendBtn: document.getElementById('send-btn')
    };

    // Initialize App
    document.addEventListener('DOMContentLoaded', () => {
      console.log('App loading...');
      
      checkProfile();
      setupEventListeners();
      
      // Auto-select default chat if user exists
      if (state.currentUser) {
        setTimeout(() => {
          initializeApp();
        }, 100);
      }
      
      console.log('App loaded');
    });

    // Initialize app after profile
    function initializeApp() {
      loadPrivacySettings();
      loadBlockedUsers();
      initializeChats();
      updateAllUnreadCounts();
      renderChatCards();
      
      // Check for new messages every 1 second
      setInterval(fetchNewMessages, 1000);
      
      // Check for notifications every 5 seconds
      setInterval(checkNotifications, 5000);
    }

    // Debug function
    function debugAppState() {
      console.log('=== DEBUG APP STATE ===');
      console.log('Current User:', state.currentUser);
      console.log('Current Chat:', state.currentChat);
      console.log('Chats:', Object.keys(state.chats));
      console.log('Current Section:', state.currentSection);
      console.log('========================');
    }

    // Load privacy settings
    function loadPrivacySettings() {
      const savedSettings = localStorage.getItem('chatAppPrivacySettings');
      if (savedSettings) {
        state.privacySettings = JSON.parse(savedSettings);
      }
    }

    // Save privacy settings
    function savePrivacySettings() {
      localStorage.setItem('chatAppPrivacySettings', JSON.stringify(state.privacySettings));
      showToast('Privacy settings saved', 'success');
      closeModal('privacy-modal');
    }

    // Load blocked users
    function loadBlockedUsers() {
      const savedBlocked = localStorage.getItem('chatAppBlockedUsers');
      if (savedBlocked) {
        state.blockedUsers = JSON.parse(savedBlocked);
      }
    }

    // Save blocked users
    function saveBlockedUsers() {
      localStorage.setItem('chatAppBlockedUsers', JSON.stringify(state.blockedUsers));
    }

    // Show modal
    function showModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.classList.add('active');
      }
    }

    // Close modal
    function closeModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.classList.remove('active');
      }
    }

    // Show privacy settings
    function showPrivacySettings() {
      showModal('privacy-modal');
      
      // Set current selection
      document.querySelectorAll('.privacy-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      const selectedOption = document.querySelector(`.privacy-option[onclick*="${state.privacySettings.whoCanMessage}"]`);
      if (selectedOption) {
        selectedOption.classList.add('selected');
      }
    }

    // Close privacy modal
    function closePrivacyModal() {
      closeModal('privacy-modal');
    }

    // Select privacy option
    function selectPrivacyOption(option) {
      state.privacySettings.whoCanMessage = option;
      
      document.querySelectorAll('.privacy-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      
      const selected = document.querySelector(`.privacy-option[onclick*="${option}"]`);
      if (selected) {
        selected.classList.add('selected');
      }
    }

    // Show blocked users
    function showBlockedUsers() {
      showModal('blocked-modal');
      renderBlockedUsersList();
    }

    // Close blocked users modal
    function closeBlockedModal() {
      closeModal('blocked-modal');
    }

    // Render blocked users list
    function renderBlockedUsersList() {
      if (!elements.blockedUsersList) return;
      
      elements.blockedUsersList.innerHTML = '';
      
      if (state.blockedUsers.length === 0) {
        elements.blockedUsersList.innerHTML = 
          '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No blocked users</div>';
        return;
      }
      
      state.blockedUsers.forEach(user => {
        const item = document.createElement('div');
        item.className = 'blocked-user-item';
        item.innerHTML = `
          <div class="blocked-user-name">${user}</div>
          <button class="unblock-btn" onclick="unblockUser('${user}')">Unblock</button>
        `;
        elements.blockedUsersList.appendChild(item);
      });
    }

    // Block a user
    function blockUser(username) {
      if (!state.blockedUsers.includes(username)) {
        state.blockedUsers.push(username);
        saveBlockedUsers();
        
        // Remove any pending requests from this user
        state.messageRequests = state.messageRequests.filter(req => req.sender !== username);
        
        // Remove from chats if exists
        if (state.chats[username]) {
          delete state.chats[username];
        }
        
        // Re-render
        renderChatCards();
        showToast(`${username} has been blocked`, 'success');
      }
    }

    // Unblock a user
    function unblockUser(username) {
      state.blockedUsers = state.blockedUsers.filter(user => user !== username);
      saveBlockedUsers();
      renderBlockedUsersList();
      showToast(`${username} has been unblocked`, 'success');
    }

    // Check if user can message based on privacy settings
    function canUserMessage(sender) {
      if (state.blockedUsers.includes(sender)) {
        return false;
      }
      
      switch (state.privacySettings.whoCanMessage) {
        case 'everyone':
          return true;
        case 'contacts':
          return state.users.includes(sender) || state.userContacts.includes(sender);
        case 'nobody':
          return false;
        default:
          return true;
      }
    }

    // Profile Management
    function checkProfile() {
      const savedProfile = localStorage.getItem('chatAppProfile');
      if (savedProfile) {
        try {
          const profile = JSON.parse(savedProfile);
          state.currentUser = profile.name;
          elements.profileDisplayName.textContent = profile.name;
          elements.profileStatusText.textContent = profile.status || 'Online';
          elements.avatarInitials.textContent = getInitials(profile.name);
          
          // Load user contacts
          const savedContacts = localStorage.getItem('chatAppContacts');
          if (savedContacts) {
            state.userContacts = JSON.parse(savedContacts);
            state.userContacts.forEach(contact => {
              if (!state.users.includes(contact)) {
                state.users.push(contact);
              }
            });
          }
          
          console.log('Profile loaded:', profile.name);
          
        } catch (error) {
          console.error('Error loading profile:', error);
          showModal('profile-modal');
        }
      } else {
        showModal('profile-modal');
      }
    }

    // Save profile function
    function saveProfile() {
      const name = elements.profileName.value.trim();
      const status = elements.profileStatus.value.trim() || 'Online';
      
      console.log('Saving profile - Name:', name, 'Status:', status);
      
      if (!name) {
        showToast('Please enter your name', 'error');
        return;
      }
      
      const profile = {
        name,
        status,
        createdAt: new Date().toISOString()
      };
      
      // Save to localStorage
      localStorage.setItem('chatAppProfile', JSON.stringify(profile));
      console.log('Profile saved to localStorage');
      
      // Update state
      state.currentUser = name;
      
      // Update UI
      elements.profileDisplayName.textContent = name;
      elements.profileStatusText.textContent = status;
      elements.avatarInitials.textContent = getInitials(name);
      
      // Hide modal
      closeModal('profile-modal');
      console.log('Modal hidden');
      
      // Add to users list
      if (!state.users.includes(name)) {
        state.users.push(name);
      }
      
      // Load contacts
      const savedContacts = localStorage.getItem('chatAppContacts');
      if (savedContacts) {
        state.userContacts = JSON.parse(savedContacts);
        state.userContacts.forEach(contact => {
          if (!state.users.includes(contact)) {
            state.users.push(contact);
          }
        });
      }
      
      // Initialize app
      initializeApp();
      
      showToast(`Welcome ${name}!`, 'success');
      
      // Debug
      debugAppState();
    }

    // Get initials
    function getInitials(name) {
      if (!name) return 'U';
      return name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
    }

    // Get color from string
    function getColorFromString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
      }
      const hue = hash % 360;
      return `hsl(${hue}, 70%, 60%)`;
    }

    // Chat Management
    function initializeChats() {
      if (!state.currentUser) {
        console.log('No current user, skipping chat initialization');
        return;
      }
      
      console.log('Initializing chats for user:', state.currentUser);
      
      // Clear existing chats
      state.chats = {};
      
      // Initialize individual chats
      state.users.forEach(user => {
        if (user !== state.currentUser) {
          state.chats[user] = {
            id: user,
            name: user,
            type: 'individual',
            messages: [],
            lastActivity: null,
            unread: 0
          };
        }
      });
      
      // Initialize group chats
      state.groups.forEach(group => {
        state.chats[group] = {
          id: group,
          name: group,
          type: 'group',
          messages: [],
          lastActivity: null,
          unread: 0
        };
      });
      
      console.log('Chats initialized:', Object.keys(state.chats));
    }

    // Render chat cards
    function renderChatCards() {
      if (!elements.cardsContainer) return;
      
      elements.cardsContainer.innerHTML = '';
      
      // Filter chats based on current section
      let chatsToShow = [];
      
      if (state.currentSection === 'chats') {
        // Show regular chats (not requests)
        chatsToShow = Object.values(state.chats).filter(chat => 
          !chat.isRequest && chat.type !== 'request'
        );
        elements.pageTitle.textContent = 'Chats';
        elements.pageSubtitle.textContent = 'All your conversations';
      } else if (state.currentSection === 'requests') {
        // Show message requests
        chatsToShow = Object.values(state.chats).filter(chat => 
          chat.isRequest || chat.type === 'request'
        );
        elements.pageTitle.textContent = 'Message Requests';
        elements.pageSubtitle.textContent = 'Pending message requests';
      } else if (state.currentSection === 'groups') {
        // Show only groups
        chatsToShow = Object.values(state.chats).filter(chat => 
          chat.type === 'group'
        );
        elements.pageTitle.textContent = 'Groups';
        elements.pageSubtitle.textContent = 'Group conversations';
      }
      
      // Sort by last activity (most recent first)
      chatsToShow.sort((a, b) => {
        if (a.lastActivity && b.lastActivity) {
          return new Date(b.lastActivity) - new Date(a.lastActivity);
        }
        if (a.lastActivity && !b.lastActivity) return -1;
        if (!a.lastActivity && b.lastActivity) return 1;
        return a.name.localeCompare(b.name);
      });
      
      // Add chat cards
      chatsToShow.forEach(chat => {
        const chatCard = createChatCard(chat);
        elements.cardsContainer.appendChild(chatCard);
      });
      
      // Show welcome message if no chats
      if (chatsToShow.length === 0) {
        let message = '';
        if (state.currentSection === 'requests') {
          message = 'No pending message requests';
        } else if (state.currentSection === 'groups') {
          message = 'No group chats yet';
        } else {
          message = 'No chats yet. Add contacts to start chatting!';
        }
        elements.welcomeMessage.innerHTML = `<p>${message}</p>`;
        elements.welcomeMessage.style.display = 'block';
      } else {
        elements.welcomeMessage.style.display = 'none';
      }
      
      // Update requests badge
      updateRequestsBadge();
    }

    // Create chat card
    function createChatCard(chat) {
      const isRequest = chat.isRequest || chat.type === 'request';
      const isActive = chat.id === state.currentChat;
      const initials = getInitials(chat.name);
      const color = getColorFromString(chat.name);
      const lastMessage = getLastMessagePreview(chat);
      const time = formatTime(chat.lastActivity);
      
      // Calculate unread count for this chat
const unreadCount = calculateUnreadCount(chat);
const hasUnread = unreadCount > 0;

const card = document.createElement('div');
card.className = `chat-card ${isActive ? 'active' : ''} ${isRequest ? 'request-card' : ''} ${hasUnread ? 'has-unread' : ''}`;
card.dataset.chatId = chat.id;
      
      // Status text
      let statusText = '';
      if (isRequest) {
        statusText = 'Message Request';
      } else if (chat.type === 'group') {
        statusText = 'Group ‚Ä¢ ' + (chat.name === 'Global Chat' ? '8 members' : '3 members');
      } else {
        statusText = chat.lastActivity ? 'Last seen ' + time : 'Not connected';
      }
      
      card.innerHTML = `
        <div class="chat-card-header">
          <div class="chat-card-avatar" style="background: ${color}">${initials}</div>
          <div class="chat-card-info">
            <div class="chat-card-title">
              <div class="chat-card-name">${chat.name}</div>
              <div class="chat-card-time">${time}</div>
            </div>
            <div class="chat-card-status">${statusText}</div>
            <div class="chat-card-preview">${lastMessage}</div>
          </div>
        </div>
        ${hasUnread ? `<div class="chat-card-badge">${unreadCount}</div>` : ''}
        ${isRequest ? `<div class="request-indicator">Request</div>` : ''}
      `;
      
      // Add click event
      card.addEventListener('click', () => openChatView(chat.id));
      
      // Add request actions if needed
      if (isRequest) {
        const actions = document.createElement('div');
        actions.className = 'chat-card-actions';
        actions.innerHTML = `
          <button class="card-btn accept" onclick="event.stopPropagation(); acceptRequest('${chat.sender || chat.name}')">Accept</button>
          <button class="card-btn decline" onclick="event.stopPropagation(); declineRequest('${chat.sender || chat.name}')">Decline</button>
          <button class="card-btn block" onclick="event.stopPropagation(); blockUserRequest('${chat.sender || chat.name}')">Block</button>
        `;
        card.appendChild(actions);
      }
      
      return card;
    }

    // Open chat view
    function openChatView(chatId) {
      const chat = state.chats[chatId];
      if (!chat) return;
      
      state.currentChat = chatId;

      // MARK CHAT AS READ WHEN OPENED
      markChatAsRead(chatId);
      
      // Update chat view UI
      elements.currentChatInitials.textContent = getInitials(chat.name);
      elements.currentChatAvatar.style.background = getColorFromString(chat.name);
      elements.currentChatTitle.textContent = chat.name;
      
      if (chat.type === 'group') {
        elements.currentChatSubtitle.textContent = 'Group ‚Ä¢ ' + (chat.name === 'Global Chat' ? '8 members' : '3 members');
      } else if (chat.isRequest) {
        elements.currentChatSubtitle.textContent = 'Message Request ‚Ä¢ Tap to view';
     } else if (chat.isTemporary) {
    elements.currentChatSubtitle.textContent = 'Tap to add to contacts';
      } else {
        elements.currentChatSubtitle.textContent = 'Online';
      }
      
        // Enable input
       elements.messageInput.disabled = false;
       elements.sendBtn.disabled = false;
       elements.messageInput.focus();
      
      // Clear unread count
      chat.unread = 0;
      
      // Show chat view
      elements.chatView.classList.add('active');
      
      // Load messages
      loadChatMessages();
      
      // Update cards (remove active class from others)
      document.querySelectorAll('.chat-card').forEach(card => {
        card.classList.remove('active');
        if (card.dataset.chatId === chatId) {
          card.classList.add('active');
        }
      });
    }

    // Close chat view
    function closeChatView() {
        const currentChat = state.chats[state.currentChat];

  if (currentChat && currentChat.isTemporary && (!currentChat.messages || currentChat.messages.length === 0)) {
    delete state.chats[state.currentChat];
    renderChatCards(); // Update the card list
  }
      state.currentChat = null;
      elements.chatView.classList.remove('active');
      
      // Clear message input
      elements.messageInput.value = '';
      
      // Update cards
      document.querySelectorAll('.chat-card').forEach(card => {
        card.classList.remove('active');
      });
    }

    // Add CSS for clickable usernames (add this to your CSS):
const clickableUsernameCSS = `
.clickable-username {
  cursor: pointer !important;
  transition: opacity 0.2s !important;
}

.clickable-username:hover {
  opacity: 0.8 !important;
}

/* Style for username options in chat header */
.username-actions {
  display: flex;
  gap: 5px;
  margin-top: 5px;
}

.username-action-btn {
  padding: 3px 8px;
  font-size: 10px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: opacity 0.2s;
}

.username-action-btn:hover {
  opacity: 0.9;
}

.username-action-btn.add {
  background: var(--online-status);
  color: white;
}

.username-action-btn.chat {
  background: var(--primary-color);
  color: white;
}
`;

// Inject the CSS
const style = document.createElement('style');
style.textContent = clickableUsernameCSS;
document.head.appendChild(style);

    // Load chat messages
    function loadChatMessages() {
      if (!elements.messagesContainer) return;
      
      elements.messagesContainer.innerHTML = '';
      
      const chat = state.chats[state.currentChat];

        // Add "Add to Contacts" button for temporary chats
  if (chat.isTemporary && chat.type === 'individual') {
    const addContactHeader = document.createElement('div');
    addContactHeader.className = 'temporary-chat-header';
    addContactHeader.style.background = 'var(--card-bg)';
    addContactHeader.style.padding = '15px';
    addContactHeader.style.borderRadius = '10px';
    addContactHeader.style.marginBottom = '20px';
    addContactHeader.style.textAlign = 'center';
    addContactHeader.style.border = '1px solid var(--border-color)';
    
    addContactHeader.innerHTML = `
      <p style="margin-bottom: 10px; color: var(--text-secondary);">
        You're chatting with <strong>${chat.name}</strong> who is not in your contacts
      </p>
      <button onclick="addUserToContacts('${chat.name}')" 
              style="background: var(--online-status); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">
        <i class="fas fa-user-plus" style="margin-right: 5px;"></i>
        Add to Contacts
      </button>
    `;
    
    elements.messagesContainer.appendChild(addContactHeader);
  }

  // Rest of the existing loadChatMessages code...
      if (!chat || !chat.messages || chat.messages.length === 0) {
        if (chat && chat.isRequest) {
          // Show request view
          showRequestView(chat);
          return;
        }
        const welcome = document.createElement('div');
        welcome.className = 'welcome-message';
        welcome.innerHTML = `<p>No messages yet. Start the conversation!</p>`;
        elements.messagesContainer.appendChild(welcome);
        return;
      }
      
      let lastDate = null;
      chat.messages.forEach(message => {
        const messageDate = formatDate(message.timestamp);
        if (messageDate !== lastDate) {
          const dateSeparator = document.createElement('div');
          dateSeparator.className = 'date-separator';
          dateSeparator.innerHTML = `<span>${messageDate}</span>`;
          elements.messagesContainer.appendChild(dateSeparator);
          lastDate = messageDate;
        }
        
         // Load saved reactions for this message
  const messageWithReactions = loadSavedReactions(message);
  
  const messageElement = createMessageElement(messageWithReactions);
  elements.messagesContainer.appendChild(messageElement);
      });
      
      scrollToBottom();

      // After loading messages, apply linkification
setTimeout(() => {
  applyLinkificationToExistingMessages();
}, 100);
    }

    // Show request view
    function showRequestView(chat) {
      const lastMessage = chat.messages[chat.messages.length - 1];
      
      elements.messagesContainer.innerHTML = `
        <div class="request-view">
          <div class="request-avatar-large">${getInitials(chat.name)}</div>
          <h2 class="request-title">Message Request</h2>
          <p>You have a message request from <strong>${chat.name}</strong></p>
          
          <div class="request-message">
            "${lastMessage.text}"
            <div class="request-meta">
              Received ${formatTime(lastMessage.timestamp)}
            </div>
          </div>
          
          <div class="request-actions-large">
            <button class="request-btn-large accept" onclick="acceptRequest('${chat.name}')">
              Accept
            </button>
            <button class="request-btn-large decline" onclick="declineRequest('${chat.name}')">
              Decline
            </button>
            <button class="request-btn-large block" onclick="blockUserRequest('${chat.name}')">
              Block
            </button>
          </div>
        </div>
      `;
    }

    // Create message element
    function createMessageElement(message) {

        // Skip rendering if it's a reaction message
  if (message.isReactionMessage) {
    return document.createElement('div'); // Return empty div
  }

  const div = document.createElement('div');
  const isSent = message.sender === state.currentUser;
  div.className = `message ${isSent ? 'sent' : 'received'}`;
  
  const time = formatMessageTime(message.timestamp);
  const messageId = message.localId || Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      // Store the message ID for later reference
  message.localId = messageId; // Ensure localId exists
  div.dataset.messageId = messageId; // Use the actual message ID

  // Ensure message has reactions object
  message.reactions = message.reactions || {};
  
  // Create reaction elements
  const reactionsHTML = createReactionElement(message);
  

  // Create message actions
  const messageActions = document.createElement('div');
  messageActions.className = 'message-actions';
  messageActions.innerHTML = `
   <button class="message-action-btn" title="React" onclick="event.stopPropagation(); toggleReactionPicker('${messageId}', this)">
    <i class="fas fa-smile"></i>
  </button>
    <button class="message-action-btn" title="Reply" onclick="event.stopPropagation(); setupReply('${messageId}', '${escapeHtml(message.sender)}', '${escapeHtml(message.text)}')">
      <i class="fas fa-reply"></i>
    </button>
    <button class="message-action-btn" title="Forward" onclick="event.stopPropagation(); setupForward('${messageId}', '${escapeHtml(message.sender)}', '${escapeHtml(message.text)}')">
      <i class="fas fa-share"></i>
    </button>
    <button class="message-action-btn" title="cancel" onclick="cancelReply()">
      <i class="fas fa-xmark"></i>
    </button>
  `;
  
  // Check if this is a group chat and message is from someone else
  const chat = state.chats[state.currentChat];
  const isGroupChat = chat && chat.type === 'group';
  const isOtherUser = message.sender !== state.currentUser;
  
  let messageContent = '';
  
// Replace the reply indicator HTML creation with this:
if (message.isReply && message.replyTo) {
  const canJumpToOriginal = message.replyTo.identifier && 
                           (chat.type !== 'group' || message.replyTo.sender === state.currentUser || 
                            message.sender === message.replyTo.sender);
  
  const indicatorClass = canJumpToOriginal ? 'reply-to-indicator clickable' : 'reply-to-indicator';
  const titleText = canJumpToOriginal ? 'Click to jump to original message' : 'Reply to another message';
  
  messageContent += `
    <div class="${indicatorClass}" ${canJumpToOriginal ? `onclick="scrollToReply('${message.replyTo.identifier}', '${escapeHtml(message.replyTo.sender)}', '${escapeHtml(message.replyTo.text)}')"` : ''} title="${titleText}">
      <i class="fas fa-reply"></i>
      <span class="reply-sender-name" style="color: yellow">${escapeHtml(message.replyTo.sender)}</span>
      <span class="reply-preview-text">
        ${escapeHtml(message.replyTo.text.substring(0, 60))}${message.replyTo.text.length > 60 ? '...' : ''}
      </span>
    </div>
  `;
}
  
  // Add forwarded indicator if this is forwarded
  if (message.isForwarded) {
    messageContent += `
      <div class="reply-to-indicator" style="color:  #0084ff; background: black"
        <i class="fas fa-share"></i>
        <i class="fas fa-share"></i> ${escapeHtml(message.originalSender)}
      </div>
    `;
  }
  
  if (isGroupChat && isOtherUser) {
    // Create clickable username
    const usernameSpan = document.createElement('span');
    usernameSpan.className = 'message-sender clickable-username';
    usernameSpan.textContent = message.sender;
    usernameSpan.dataset.username = message.sender;
    usernameSpan.title = `Click to chat with ${message.sender}`;
    usernameSpan.style.cursor = 'pointer';
    usernameSpan.style.color = getColorFromString(message.sender);
    usernameSpan.style.textDecoration = 'underline';
    
    usernameSpan.addEventListener('click', (e) => {
      e.stopPropagation();
      handleUsernameClick(message.sender);
    });
    
    // Parse text for clickable links and phone numbers
    const parsedText = parseAndLinkify(message.text);
    
 div.innerHTML = `
    ${messageContent}
    <div class="message-text">${parsedText}</div>
    ${reactionsHTML}
    <div class="message-time">${time}</div>
  `;
    
    // Insert username and actions
    div.insertBefore(usernameSpan, div.firstChild);
    div.appendChild(messageActions);
    
  } else {
    // Regular message with actions
    const parsedText = parseAndLinkify(message.text);

    div.innerHTML = `
    ${messageContent}
    <div class="message-text">${parsedText}</div>
    ${reactionsHTML}
    <div class="message-time">${time}</div>
  `;
    div.appendChild(messageActions);
  }
  
  // Add click handler to show actions on mobile
  div.addEventListener('click', (e) => {
    if (window.innerWidth <= 768) {
      messageActions.style.opacity = '1';
      messageActions.style.transform = 'translateY(0)';
      
      // Hide after delay
      setTimeout(() => {
        if (document.activeElement !== messageActions.querySelector('button')) {
          messageActions.style.opacity = '0';
          messageActions.style.transform = 'translateY(10px)';
        }
      }, 3000);
    }
  });
  
  return div;
}

// Add this reply function to scroll to original message
function scrollToReply(identifier, originalSender, originalText) {
  const currentChat = state.chats[state.currentChat];
  if (!currentChat) {
    showToast('No chat selected', 'info');
    return;
  }
  
  console.log('Looking for reply to:', { identifier, originalSender, originalText });
  
  // Try to find the original message by content
  // Look for messages from the same sender with similar text
  const originalMessage = currentChat.messages.find(msg => {
    // Check if this message matches the reply identifier
    if (msg.replyTo && msg.replyTo.identifier === identifier) {
      return true; // Direct match by identifier
    }
    
    // Content-based matching (fallback)
    const isSameSender = msg.sender === originalSender;
    const hasSimilarText = msg.text && originalText && 
                          (msg.text.includes(originalText.substring(0, 20)) || 
                           originalText.includes(msg.text.substring(0, 20)));
    
    return isSameSender && hasSimilarText;
  });
  
  if (originalMessage) {
    console.log('Found original message:', originalMessage);
    
    // Find the message element in DOM
    let messageElement;
    
    // Try by localId first
    if (originalMessage.localId) {
      messageElement = document.querySelector(`[data-message-id="${originalMessage.localId}"]`);
    }
    
    // If not found, try by content
    if (!messageElement) {
      // Find element that contains the text
      const allMessages = document.querySelectorAll('.message');
      for (const element of allMessages) {
        if (element.textContent.includes(originalMessage.text.substring(0, 30))) {
          messageElement = element;
          break;
        }
      }
    }
    
    if (messageElement) {
      console.log('Found DOM element, scrolling...');
      // Scroll to and highlight the message
      messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      messageElement.classList.add('reply-highlight');
      
      // Remove highlight after animation
      setTimeout(() => {
        messageElement.classList.remove('reply-highlight');
      }, 2000);
      
      return;
    } else {
      console.log('DOM element not found');
    }
  }
  
  // If we get here, try to find any message from that sender
  const anyMessageFromSender = currentChat.messages.find(msg => 
    msg.sender === originalSender
  );
  
  if (anyMessageFromSender && anyMessageFromSender.localId) {
    const messageElement = document.querySelector(`[data-message-id="${anyMessageFromSender.localId}"]`);
    if (messageElement) {
      messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      messageElement.classList.add('reply-highlight');
      setTimeout(() => {
        messageElement.classList.remove('reply-highlight');
      }, 2000);
      return;
    }
  }
  
  // If we get here, the original message isn't in current chat
  showToast(`Could not find the original message from ${originalSender}`, 'info');
}

// Add this function to handle username clicks:
function handleUsernameClick(username) {
  // Don't allow clicking on yourself
  if (username === state.currentUser) {
    showToast('That\'s you!', 'info');
    return;
  }
  
  // Check if user is blocked
  if (state.blockedUsers.includes(username)) {
    showToast(`${username} is blocked`, 'warning');
    return;
  }
  
  // Check if user already exists in contacts
  const isInContacts = state.users.includes(username) || state.userContacts.includes(username);
  
  if (isInContacts) {
    // User is in contacts - open chat or switch to existing chat
    openChatWithUser(username);
  } else {
    // User not in contacts - show options
    showUsernameOptions(username);
  }
}


// Add this function to open chat with user:
function openChatWithUser(username) {
  // Check if chat already exists
  if (state.chats[username]) {
    // Switch to existing chat
    closeChatView(); // Close current chat view first
    setTimeout(() => {
      openChatView(username);
    }, 100);
  } else {
    // Create new chat
    state.chats[username] = {
      id: username,
      name: username,
      type: 'individual',
      messages: [],
      lastActivity: null,
      unread: 0
    };
    
    // Switch to new chat
    closeChatView(); // Close current chat view first
    setTimeout(() => {
      openChatView(username);
      showToast(`Started chat with ${username}`, 'success');
    }, 100);
  }
}

 // Add this function to show options for unknown users:
function showUsernameOptions(username) {
  // Create modal for username options
  const modalHTML = `
    <div class="modal-overlay active" id="username-options-modal">
      <div class="modal-content">
        <h2 class="modal-title">${username}</h2>
        <p style="text-align: center; margin-bottom: 20px; color: var(--text-secondary);">
          This user is not in your contacts
        </p>
        
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <button class="modal-btn primary" onclick="addUserToContacts('${username}')">
            <i class="fas fa-user-plus" style="margin-right: 8px;"></i>
            Add to Contacts & Chat
          </button>
          
          <button class="modal-btn" onclick="chatWithoutAdding('${username}')" style="background: var(--message-received);">
            <i class="fas fa-comment" style="margin-right: 8px;"></i>
            Chat Without Adding
          </button>
          
          <button class="modal-btn secondary" onclick="closeUsernameOptions()">
            Cancel
          </button>
        </div>
      </div>
    </div>
  `;
  
  // Create and show modal
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer);
}

// Add this function to add user to contacts and chat:
function addUserToContacts(username) {
  // Add to contacts
  if (!state.users.includes(username)) {
    state.users.push(username);
  }
  
  if (!state.userContacts.includes(username)) {
    state.userContacts.push(username);
    localStorage.setItem('chatAppContacts', JSON.stringify(state.userContacts));
  }
  
  // Create chat
  state.chats[username] = {
    id: username,
    name: username,
    type: 'individual',
    messages: [],
    lastActivity: null,
    unread: 0
  };
  
  // Close modal
  closeUsernameOptions();
  
  // Switch to chat
  closeChatView();
  setTimeout(() => {
    openChatView(username);
    showToast(`${username} added to contacts`, 'success');
  }, 100);
}

 // Add this function to chat without adding to contacts:
function chatWithoutAdding(username) {
  // Create temporary chat (not saved to contacts)
  state.chats[username] = {
    id: username,
    name: username,
    type: 'individual',
    messages: [],
    lastActivity: null,
    unread: 0,
    isTemporary: true // Mark as temporary
  };
  
  // Close modal
  closeUsernameOptions();
  
  // Switch to chat
  closeChatView();
  setTimeout(() => {
    openChatView(username);
    showToast(`Started chat with ${username}`, 'info');
  }, 100);
}

// Add this function to close username options modal:
function closeUsernameOptions() {
  const modal = document.getElementById('username-options-modal');
  if (modal) {
    modal.remove();
  }
}

    // Get last message preview
    function getLastMessagePreview(chat) {
      if (!chat.messages || !chat.messages.length) return 'No messages yet';
      const lastMessage = chat.messages[chat.messages.length - 1];
      const prefix = lastMessage.sender === state.currentUser ? 'You: ' : '';
      return prefix + lastMessage.text.substring(0, 50) + (lastMessage.text.length > 50 ? '...' : '');
    }

    // Format date
function formatDate(dateString) {
  if (!dateString) return '';
  
  const messageDate = new Date(dateString);
  const today = new Date();
  
  // Reset times to compare only dates
  const messageDay = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate());
  const todayDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const yesterdayDay = new Date(todayDay);
  yesterdayDay.setDate(yesterdayDay.getDate() - 1);
  
  // Compare dates (ignoring time)
  if (messageDay.getTime() === todayDay.getTime()) {
    return 'Today';
  } else if (messageDay.getTime() === yesterdayDay.getTime()) {
    return 'Yesterday';
  } else {
    // More than 2 days ago
    return messageDate.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: today.getFullYear() !== messageDate.getFullYear() ? 'numeric' : undefined
    });
  }
}

    // Format message time
    function formatMessageTime(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      });
    }

    // Format time
    function formatTime(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      const now = new Date();
      const diff = now - date;
      
      if (diff < 60000) {
        return 'Just now';
      } else if (diff < 3600000) {
        return Math.floor(diff / 60000) + 'm ago';
      } else if (diff < 86400000) {
        return date.toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit',
          hour12: true 
        });
      } else {
        return date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric' 
        });
      }
    }

    // Scroll to bottom
    function scrollToBottom() {
      if (!elements.messagesContainer) return;
      elements.messagesContainer.scrollTop = elements.messagesContainer.scrollHeight;
    }

    // Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Show section
    function showSection(section) {
      state.currentSection = section;
      
      // Update active menu item
      document.querySelectorAll('.menu-item').forEach(item => {
        item.classList.remove('active');
      });
      
      if (section === 'chats') {
        document.querySelector('.menu-item:nth-child(1)').classList.add('active');
      } else if (section === 'requests') {
        document.querySelector('.menu-item:nth-child(2)').classList.add('active');
      } else if (section === 'groups') {
        document.querySelector('.menu-item:nth-child(3)').classList.add('active');
      }
      
      // Render chat cards for this section
      renderChatCards();
    }

    // Update requests badge
    function updateRequestsBadge() {
      if (!elements.requestsMenuItem) return;
      
      const requestCount = Object.values(state.chats).filter(chat => chat.isRequest).length;
      
      if (requestCount > 0) {
        elements.requestsMenuItem.classList.add('has-notifications');
      } else {
        elements.requestsMenuItem.classList.remove('has-notifications');
      }
    }

    // Toggle sidebar
    function toggleSidebar() {
      state.sidebarExpanded = !state.sidebarExpanded;
      elements.sidebar.classList.toggle('expanded', state.sidebarExpanded);
      
      // For mobile, use active class
      if (window.innerWidth <= 768) {
        elements.sidebar.classList.toggle('active');
      }
    }

    // Message Functions
    function sendMessage() {
  const text = elements.messageInput.value.trim();
  if (!text || !state.currentUser || !state.currentChat) return;
  
  const chat = state.chats[state.currentChat];
  if (chat && (chat.isRequest || chat.type === 'request')) {
    showToast('Cannot send messages to pending requests', 'error');
    return;
  }
  
  // Check if we're in reply mode
  if (state.replyMode && state.currentReply) {
    sendReplyMessage();
    return;
  }
  
  const messageId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  
  const message = {
    sender: state.currentUser,
    receiver: state.currentChat === 'Global Chat' ? 'GROUP' : state.currentChat,
    message: text,
    timestamp: new Date().toISOString(),
    localId: messageId,
     sharedId: createSharedMessageId({ // ADD THIS
    timestamp: new Date().toISOString(),
    sender: state.currentUser,
    receiver: state.currentChat === 'Global Chat' ? 'GROUP' : state.currentChat,
    text: text
  })
  };
  
  console.log('Sending message with ID:', messageId);
  
  state.pendingMessages.add(messageId);
  
  const existingMessage = chat.messages.find(m => 
    m.sender === state.currentUser && 
    m.text === text && 
    Math.abs(new Date(m.timestamp) - new Date(message.timestamp)) < 1000
  );
  
  if (!existingMessage) {
    chat.messages.push({
      sender: state.currentUser,
      receiver: state.currentChat,
      text: text,
      timestamp: message.timestamp,
      localId: messageId,
      sharedId: message.sharedId 
    });
    chat.lastActivity = message.timestamp;
    
    // Update card
    renderChatCards();
    
    const messageElement = createMessageElement({
      sender: state.currentUser,
      receiver: state.currentChat,
      text: text,
      timestamp: message.timestamp
    });
    elements.messagesContainer.appendChild(messageElement);
    elements.messageInput.value = '';
    
    scrollToBottom();
  }
  
  fetch(scriptUrl, {
    method: 'POST',
    mode: 'no-cors',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(message)
  })
  .then(() => {
    console.log('Message sent to backend:', messageId);
    setTimeout(() => {
      state.pendingMessages.delete(messageId);
    }, 3000);
  })
  .catch(error => {
    console.error('Error sending message:', error);
    showToast('Failed to send message', 'error');
    state.pendingMessages.delete(messageId);
  });
}

    // Fetch new messages
    function fetchNewMessages() {
      if (!state.currentUser) return;
      
      fetch(scriptUrl + '?action=get')
        .then(response => response.json())
        .then(data => {
          const newMessages = data.filter(row => {
            const messageId = row[0] + row[1] + row[2] + row[3];
            return !state.notifications.has(messageId);
          });
          
          if (newMessages.length > 0) {
            processNewMessages(newMessages);
          }
        })
        .catch(error => console.error('Error fetching messages:', error));
    }

    // Process new messages
    function processNewMessages(messages) {
      let hasNewRequests = false;
      let needsCardUpdate = false; // NEW: Track if cards need updating
      
      messages.forEach(row => {
        if (!row || row.length < 4) return;
        
        const messageId = row[0] + row[1] + row[2] + row[3];
        
        if (state.notifications.has(messageId)) return;
        
        state.notifications.add(messageId);
        
        // In processNewMessages(), update the message object creation:
const message = {
  timestamp: row[0],
  sender: row[1],
  receiver: row[2],
  text: row[3],
  localId: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
  sharedId: createSharedMessageId({
    timestamp: row[0],
    sender: row[1],
    receiver: row[2],
    text: row[3]
  })
};

console.log('üì• New message received:', {
  sender: message.sender,
  text: message.text.substring(0, 50),
  sharedId: message.sharedId
});

        // ===== ADD THIS REACTION PARSING =====
// Check if this is a reaction message
const reactionMatch = message.text.match(/\[REACTION:([^:]+):([^:]+):([^:]+):([^\]]+)\]/);
if (reactionMatch) {
  const [_, targetMessageId, emoji, reactingUser, action] = reactionMatch;
  
  // Process the reaction
  processIncomingReaction(targetMessageId, emoji, reactingUser, action, message.timestamp);
  
  // Mark this as a reaction message (to filter it out later)
  message.isReactionMessage = true;
  
  // Skip further processing for reaction messages
  return;
}

        // Check if this is a reply message
    const replyMatch = message.text.match(/\[REPLY_TO:([^:]+):([^\]]+)\] (.+) \|\| (.+)/);
    if (replyMatch) {
      // It's a reply message
      const [_, replyIdentifier, replyToSender, originalText, replyText] = replyMatch;
      
      message.isReply = true;
      message.text = replyText; // Use the reply text
      message.replyTo = {
        identifier: replyIdentifier,
        sender: replyToSender,
        text: originalText,
        timestamp: message.timestamp // Use same timestamp for now
      };
        // Ensure localId exists for this message too
  if (!message.localId) {
    message.localId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  }
    }
       
        // Skip messages from current user that we just sent
        if (message.sender === state.currentUser) {
          const isRecentMessage = new Date(message.timestamp).getTime() > Date.now() - 5000;
          if (isRecentMessage) {
            console.log('Skipping own recent message from backend:', message.text);
            return;
          }
        }
        
        // Check if sender is blocked
        if (state.blockedUsers.includes(message.sender)) {
          console.log('Message from blocked user:', message.sender);
          return;
        }
        
        // Determine which chat this belongs to
        let chatId;
        let isRequest = false;
        
        if (message.receiver === 'GROUP' || message.receiver === 'Global Chat') {
          chatId = 'Global Chat';
        } else if (message.receiver === state.currentUser) {
          chatId = message.sender;
          
          // Check if this is a message from someone not in contacts
          if (!state.users.includes(message.sender) && !state.userContacts.includes(message.sender)) {
            if (canUserMessage(message.sender)) {
              isRequest = true;
              hasNewRequests = true;
              
              const requestId = `request_${message.sender}`;
              chatId = requestId;
              
              if (!state.chats[requestId]) {
                state.chats[requestId] = {
                  id: requestId,
                  name: message.sender,
                  sender: message.sender,
                  type: 'request',
                  isRequest: true,
                  messages: [message],
                  lastActivity: message.timestamp,
                  unread: 1,
                  createdAt: new Date().toISOString()
                };
                
                showRequestNotification(message.sender, message.text);
                needsCardUpdate = true; // Cards need update
              } else {
                const requestChat = state.chats[requestId];
                requestChat.messages.push(message);
                requestChat.lastActivity = message.timestamp;
                requestChat.unread++;
                needsCardUpdate = true; // Cards need update
              }
            } else {
              console.log('Message blocked by privacy settings from:', message.sender);
              return;
            }
          }
        } else if (message.sender === state.currentUser) {
          chatId = message.receiver;
        } else {
          return;
        }
        
        // Add to chat (if not a request already handled above)
        if (state.chats[chatId] && !isRequest) {
          const chat = state.chats[chatId];
          
          const existingMessage = chat.messages.find(m => 
            m.sender === message.sender && 
            m.text === message.text && 
            Math.abs(new Date(m.timestamp) - new Date(message.timestamp)) < 1000
          );
          
          if (!existingMessage) {
    // Check if this is a forwarded message from the current user
    if (message.text.includes('[FORWARDED_FROM:')) {
        const forwardMatch = message.text.match(/\[FORWARDED_FROM:([^\]]+)\] (.+)/);
        if (forwardMatch) {
            const [_, originalSender, originalText] = forwardMatch;
            
            // Create proper forward structure
            const forwardMessage = {
                ...message,
                text: originalText,
                isForwarded: true,
                originalSender: originalSender
            };
            
            chat.messages.push(forwardMessage);
        } else {
            chat.messages.push(message);
        }
    } 
    
    else if (message.sender === state.currentUser && message.text.includes('[Forwarded from')) {
        chat.messages.push({
            ...message,
            isForwarded: true
        });
    } 

    // Regular message
    else {
        chat.messages.push(message);
    }
 
    chat.lastActivity = message.timestamp;

            // Mark that cards need update
            needsCardUpdate = true;
            
            if (chatId !== state.currentChat) {
  // Calculate unread count based on timestamps
  chat.unread = calculateUnreadCount(chat);
  showNotification(message);
}
          }
        }
      });
      
      // Update requests badge
      if (hasNewRequests) {
        updateRequestsBadge();
      }

       // NEW: Update chat cards if needed
       if (needsCardUpdate) {
       renderChatCards();
      }
      
      // If current chat is active, reload messages
      if (state.currentChat) {
        loadChatMessages();
      }
    }

    // Helper function to format reply messages for display
function formatReplyForDisplay(sender, originalText, replyText) {
  return `‚Ü™ Replying to "${originalText.substring(0, 30)}..."`;
}

    // Show request notification
    function showRequestNotification(sender, messageText) {
      if (!elements.requestNotification || !elements.requestNotificationText) return;
      
      elements.requestNotificationText.textContent = `${sender}: ${messageText.substring(0, 50)}...`;
      elements.requestNotification.classList.add('active');
      
      setTimeout(() => {
        if (elements.requestNotification) {
          elements.requestNotification.classList.remove('active');
        }
      }, 10000);
    }

    // View message request
    function viewMessageRequest() {
      const requests = Object.values(state.chats).filter(chat => chat.isRequest);
      if (requests.length > 0) {
        requests.sort((a, b) => new Date(b.lastActivity) - new Date(a.lastActivity));
        const latestRequest = requests[0];
        
        showSection('requests');
        openChatView(latestRequest.id);
      }
      
      if (elements.requestNotification) {
        elements.requestNotification.classList.remove('active');
      }
    }

    // Dismiss request notification
    function dismissRequestNotification() {
      if (elements.requestNotification) {
        elements.requestNotification.classList.remove('active');
      }
    }

    // Accept request
    function acceptRequest(sender) {
      const requestId = `request_${sender}`;
      
      if (state.chats[requestId]) {
        const requestChat = state.chats[requestId];
        delete state.chats[requestId];
        
        if (!state.users.includes(sender) && !state.userContacts.includes(sender)) {
          state.userContacts.push(sender);
          state.users.push(sender);
          localStorage.setItem('chatAppContacts', JSON.stringify(state.userContacts));
        }
        
        state.chats[sender] = {
          id: sender,
          name: sender,
          type: 'individual',
          messages: requestChat.messages,
          lastActivity: requestChat.lastActivity,
          unread: calculateUnreadCount(requestChat)
        };

         // Handle new chat unread status
    handleNewChat(sender, requestChat.messages[0]);
        
        // If we're in the request, close chat view
        if (state.currentChat === requestId) {
          closeChatView();
        }
        
        renderChatCards();
        showToast(`${sender} added to contacts`, 'success');
      }
    }

    // Decline request
    function declineRequest(sender) {
      const requestId = `request_${sender}`;
      
      if (state.chats[requestId]) {
        delete state.chats[requestId];
        
        if (state.currentChat === requestId) {
          closeChatView();
        }
        
        renderChatCards();
        showToast('Message request declined', 'info');
      }
    }

    // Block user from request
    function blockUserRequest(sender) {
      blockUser(sender);
      
      const requestId = `request_${sender}`;
      if (state.chats[requestId]) {
        delete state.chats[requestId];
        
        if (state.currentChat === requestId) {
          closeChatView();
        }
      }
      
      renderChatCards();
    }

    // Show notification
    function showNotification(message) {
      if (!elements.taskbarNotification || !elements.notificationText) return;
      
      elements.notificationText.textContent = `New message from ${message.sender}`;
      elements.taskbarNotification.classList.add('active');
      
      Toastify({
        text: `New message from ${message.sender}: ${message.text.substring(0, 50)}...`,
        duration: 3000,
        gravity: "top",
        position: "right",
        backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)",
        stopOnFocus: true
      }).showToast();
      
      if (navigator.vibrate) {
        navigator.vibrate([200, 100, 200]);
      }
      
      setTimeout(() => {
        if (elements.taskbarNotification) {
          elements.taskbarNotification.classList.remove('active');
        }
      }, 5000);
    }

    // Check notifications
    function checkNotifications() {
      let hasUnread = false;

        // Calculate unread counts for all chats
  updateAllUnreadCounts();

        // Check if any chat has unread messages (except current chat)
  for (const chatId in state.chats) {
    const chat = state.chats[chatId];
    if (chat.unread > 0 && chatId !== state.currentChat) {
      hasUnread = true;
      break;
    }
  }
      
      document.title = hasUnread ? '(*) ChatApp' : 'ChatApp';
    }

    // Clear chat
    function clearChat() {
      if (!state.currentChat) return;
      
      if (confirm('Clear all messages in this chat?')) {
        state.chats[state.currentChat].messages = [];
        loadChatMessages();
        showToast('Chat cleared', 'info');
      }
    }

    // Initiate video call
    function initiateVideoCall() {
      window.open('https://meet.jit.si/GRWCChurchConference', '_blank');
      showToast('Starting video call...', 'info');
    }

    // Show toast
    function showToast(message, type = 'info') {
      const backgroundColor = type === 'error' ? '#f02849' : 
                             type === 'success' ? '#31a24c' : 
                             type === 'warning' ? '#ff9500' :
                             '#0084ff';
      
      Toastify({
        text: message,
        duration: 3000,
        gravity: "top",
        position: "right",
        backgroundColor: backgroundColor,
        stopOnFocus: true
      }).showToast();
    }

    // Contact Management
    function showAddContactModal() {
      showModal('add-contact-modal');
      if (elements.newContactName) {
        elements.newContactName.value = '';
      }
      renderAvailableUsersList();
    }

    function closeAddContactModal() {
      closeModal('add-contact-modal');
    }

    function addNewContact() {
      if (!elements.newContactName) return;
      
      const contactName = elements.newContactName.value.trim();
      
      if (!contactName) {
        showToast('Please enter a username', 'error');
        return;
      }
      
      if (contactName === state.currentUser) {
        showToast('Cannot add yourself as a contact', 'error');
        return;
      }
      
      if (state.users.includes(contactName)) {
        showToast('Contact already exists', 'info');
        closeAddContactModal();
        return;
      }
      
      state.users.push(contactName);
      
      if (!state.userContacts.includes(contactName)) {
        state.userContacts.push(contactName);
        localStorage.setItem('chatAppContacts', JSON.stringify(state.userContacts));
      }
      
      state.chats[contactName] = {
        id: contactName,
        name: contactName,
        type: 'individual',
        messages: [],
        lastActivity: null,
        unread: 0
      };
      
      renderChatCards();
      showToast(`Added ${contactName} as contact`, 'success');
      closeAddContactModal();
    }

    function renderAvailableUsersList() {
      if (!elements.availableUsersList) return;
      
      elements.availableUsersList.innerHTML = '';
      
      const allUsers = ["Rev", "Ska", "kinaa", "Eyram", "Yayra", "Stephen", "Diana"];
      const availableUsers = allUsers.filter(user => 
        user !== state.currentUser && !state.users.includes(user)
      );
      
      if (availableUsers.length === 0) {
        elements.availableUsersList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No available users to add</div>';
        return;
      }
      
      availableUsers.forEach(user => {
        const contactItem = document.createElement('div');
        contactItem.className = 'contact-item';
        contactItem.innerHTML = `
          <div>
            <div class="contact-name">${user}</div>
            <div class="contact-status">Click to add</div>
          </div>
          <i class="fas fa-plus" style="color: var(--text-secondary);"></i>
        `;
        
        contactItem.onclick = () => {
          if (elements.newContactName) {
            elements.newContactName.value = user;
          }
        };
        
        elements.availableUsersList.appendChild(contactItem);
      });
    }

    // Search chats (placeholder)
    function searchChats() {
      showToast('Search functionality coming soon!', 'info');
    }

    // Refresh chats
    function refreshChats() {
      fetchNewMessages();
      showToast('Refreshing chats...', 'info');
    }

    // Setup event listeners
    function setupEventListeners() {
      // Enter key to send message
      if (elements.messageInput) {
        elements.messageInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        });
      }

        // Add: Escape key to cancel reply
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && state.replyMode) {
      cancelReply();
      e.preventDefault();
    }
  });
  
  // Add: Click outside to hide message actions
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.message') && !e.target.closest('.message-actions')) {
      document.querySelectorAll('.message-actions').forEach(actions => {
        actions.style.opacity = '0';
        actions.style.transform = 'translateY(10px)';
      });
    }
  });
      
      // Profile modal enter key
      if (elements.profileName) {
        elements.profileName.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') saveProfile();
        });
      }
      
      if (elements.profileStatus) {
        elements.profileStatus.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') saveProfile();
        });
      }
      
      // Add contact modal enter key
      if (elements.newContactName) {
        elements.newContactName.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') addNewContact();
        });
      }
      
      // Close modals when clicking outside
      document.addEventListener('click', (e) => {
        if (e.target.classList.contains('modal-overlay')) {
          if (e.target.id === 'profile-modal' && state.currentUser) {
            closeModal('profile-modal');
          } else if (e.target.id === 'add-contact-modal') {
            closeModal('add-contact-modal');
          } else if (e.target.id === 'privacy-modal') {
            closeModal('privacy-modal');
          } else if (e.target.id === 'blocked-modal') {
            closeModal('blocked-modal');
          }
        }
      });
      
      // Close sidebar when clicking outside on mobile
      document.addEventListener('click', (e) => {
        if (window.innerWidth <= 768) {
          const sidebar = elements.sidebar;
          const isClickInsideSidebar = sidebar.contains(e.target);
          const isClickOnMenuButton = e.target.closest('.header-btn') !== null;
          
          if (!isClickInsideSidebar && !isClickOnMenuButton && sidebar.classList.contains('active')) {
            sidebar.classList.remove('active');
          }
        }
      });
    }

    // Add to setupEventListeners():
// Double-click to add quick reaction
document.addEventListener('dblclick', (e) => {
  const messageElement = e.target.closest('.message');
  if (messageElement && !e.target.closest('.message-actions') && !e.target.closest('.reaction')) {
    const messageId = messageElement.dataset.messageId;
    if (messageId) {
      // Add like reaction on double-click
      addReaction(messageId, 'üëç', state.currentUser);
      e.preventDefault();
      e.stopPropagation();
    }
  }
});

// Long press for reaction picker on mobile
let pressTimer;
document.addEventListener('touchstart', (e) => {
  const messageElement = e.target.closest('.message');
  if (messageElement) {
    pressTimer = setTimeout(() => {
      const messageId = messageElement.dataset.messageId;
      const messageActions = messageElement.querySelector('.message-actions');
      if (messageId && messageActions) {
        const reactButton = messageActions.querySelector('[title="React"]');
        if (reactButton) {
          toggleReactionPicker(messageId, reactButton);
        }
      }
    }, 500); // 500ms long press
  }
});

document.addEventListener('touchend', () => {
  clearTimeout(pressTimer);
});

document.addEventListener('touchmove', () => {
  clearTimeout(pressTimer);
});

    // ========== REPLY FUNCTIONALITY ==========

// Set up reply to a message
function setupReply(messageId, sender, text) {
    const replyIdentifier = createReplyIdentifier(sender, text);

     // Escape HTML to prevent issues
  const safeSender = escapeHtml(sender);
  const safeText = escapeHtml(text.substring(0, 100)); // Limit length

  state.currentReply = {
    messageId: messageId,
    identifier: replyIdentifier,
    sender,
    text,
    timestamp: new Date().toISOString()
  };
  state.replyMode = true;
  
  // Update input placeholder
  if (elements.messageInput) {
    elements.messageInput.placeholder = "Reply to " + sender + "...";
    elements.messageInput.focus();
  }
  
  // Show reply preview
  showReplyPreview();
}

// Show reply preview above input
function showReplyPreview() {
  if (!state.currentReply || !elements.inputArea) return;
  
  // Remove existing preview
  const existingPreview = document.getElementById('reply-preview');
  if (existingPreview) existingPreview.remove();
  
  // Create preview
  const preview = document.createElement('div');
  preview.id = 'reply-preview';
  preview.className = 'reply-preview';
  preview.innerHTML = `
    <div class="reply-preview-header">
      <div class="reply-preview-sender">Replying to ${state.currentReply.sender}</div>
      <button class="reply-preview-close" onclick="cancelReply()" id="cancel-reply-btn">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="reply-preview-text">${escapeHtml(state.currentReply.text)}</div>
  `;
  
   // Add event listener to X button
  setTimeout(() => {
    const cancelBtn = document.getElementById('cancel-reply-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', cancelReply);
    }
  }, 100);
  
  // Insert before input area
  const inputArea = document.querySelector('.input-area');
  if (inputArea) {
    inputArea.insertBefore(preview, elements.messageInput);
  }
  showToast('Reply mode activated', 'info');
}

// Cancel reply
function cancelReply() {
  state.currentReply = null;
  state.replyMode = false;
  
  // Remove preview
  const preview = document.getElementById('reply-preview');
  if (preview) {
    preview.remove();
  }
  
  // Reset placeholder
  if (elements.messageInput) {
    elements.messageInput.placeholder = "Type a message...";
    elements.messageInput.value = '';
  }
}

// Send reply message
// Replace the entire sendReplyMessage function with this:

function sendReplyMessage() {
  if (!state.currentReply || !state.currentChat) return;
  
  const replyText = elements.messageInput.value.trim();
  if (!replyText) {
    showToast('Please enter a reply message', 'error');
    return;
  }
  
  const chat = state.chats[state.currentChat];
  if (!chat) return;
  
  // Create message with reply info
  const messageId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  const timestamp = new Date().toISOString();

    
  // Create a content-based identifier (not message ID)
  const replyIdentifier = createReplyIdentifier(state.currentReply.sender, state.currentReply.text);
  
  // Format for backend - use content-based identifier
  const replyMessageText = `[REPLY_TO:${replyIdentifier}:${state.currentReply.sender}] ${state.currentReply.text} || ${replyText}`;

  const message = {
    timestamp: timestamp,
    sender: state.currentUser,
    receiver: state.currentChat === 'Global Chat' ? 'GROUP' : state.currentChat,
    message: replyMessageText, // Include reply metadata in message
    localId: messageId,
  };
  
  // Create display message (what shows in UI)
  const displayMessage = {
    sender: state.currentUser,
    receiver: state.currentChat,
    text: replyText,
    timestamp: timestamp,
    localId: messageId,
    isReply: true,
    replyTo: {
      identifier: replyIdentifier,
      sender: state.currentReply.sender,
      text: state.currentReply.text,
      timestamp: state.currentReply.timestamp
    },
    sharedId: createSharedMessageId({ // ADD THIS
    timestamp: timestamp,
    sender: state.currentUser,
    receiver: state.currentChat === 'Global Chat' ? 'GROUP' : state.currentChat,
    text: replyText
  })
  };
  
  // Add to chat
  chat.messages.push(displayMessage);
  chat.lastActivity = timestamp;
  
  // Update UI
  const messageElement = createMessageElement(displayMessage);
  elements.messagesContainer.appendChild(messageElement);
  scrollToBottom();
  
  // Send to backend
  fetch(scriptUrl, {
    method: 'POST',
    mode: 'no-cors',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(message)
  }).catch(error => console.error('Error sending reply:', error));
  
  // Clear reply and input
  cancelReply();
  elements.messageInput.value = '';
  
  // Update chat cards
  renderChatCards();
  showToast('Reply sent', 'success');
}


// ========== FORWARD FUNCTIONALITY ==========

// Setup forward for a message
function setupForward(messageId, sender, text) {
  state.currentForwardMessage = {
    messageId,
    sender,
    text,
    timestamp: new Date().toISOString()
  };
  state.forwardMode = true;
  
  // Update preview
  document.getElementById('forward-preview-sender').textContent = sender;
  document.getElementById('forward-preview-text').textContent = text;
  
  // Show modal and populate chats
  showModal('message-actions-modal');
  document.getElementById('message-actions-title').textContent = 'Forward Message';
  populateForwardChats();
}

// Populate forward chats list
function populateForwardChats() {
  const list = document.getElementById('forward-chats-list');
  if (!list) return;
  
  list.innerHTML = '';
  
  // Get all chats except current one and requests
  const chats = Object.values(state.chats).filter(chat => 
    !chat.isRequest && 
    chat.type !== 'request' &&
    chat.id !== state.currentChat
  );
  
  if (chats.length === 0) {
    list.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No other chats available</div>';
    return;
  }
  
  chats.forEach(chat => {
    const item = document.createElement('div');
    item.className = 'forward-chat-item';
    item.dataset.chatId = chat.id;
    
    const initials = getInitials(chat.name);
    const color = getColorFromString(chat.name);
    
    item.innerHTML = `
      <div class="forward-chat-avatar" style="background: ${color}">${initials}</div>
      <div class="forward-chat-info">
        <div class="forward-chat-name">${chat.name}</div>
        <div class="forward-chat-type">${chat.type === 'group' ? 'Group' : 'Contact'}</div>
      </div>
      <i class="fas fa-check" style="display: none; color: var(--online-status);"></i>
    `;
    
    item.onclick = () => selectForwardChat(chat.id);
    
    list.appendChild(item);
  });
}

// Select chat for forwarding
let selectedForwardChat = null;

function selectForwardChat(chatId) {
  selectedForwardChat = chatId;
  
  // Update UI
  document.querySelectorAll('.forward-chat-item').forEach(item => {
    item.classList.remove('selected');
    const checkIcon = item.querySelector('.fa-check');
    if (checkIcon) checkIcon.style.display = 'none';
  });
  
  const selectedItem = document.querySelector(`.forward-chat-item[data-chat-id="${chatId}"]`);
  if (selectedItem) {
    selectedItem.classList.add('selected');
    const checkIcon = selectedItem.querySelector('.fa-check');
    if (checkIcon) checkIcon.style.display = 'block';
  }
  
  // Enable send button
  document.getElementById('send-forward-btn').disabled = false;
}

// Filter forward chats
function filterForwardChats() {
  const searchTerm = document.getElementById('forward-search-input').value.toLowerCase();
  const items = document.querySelectorAll('.forward-chat-item');
  
  items.forEach(item => {
    const chatName = item.querySelector('.forward-chat-name').textContent.toLowerCase();
    if (chatName.includes(searchTerm)) {
      item.style.display = 'flex';
    } else {
      item.style.display = 'none';
    }
  });
}

// Send forwarded message
function sendForwardedMessage() {
  if (!selectedForwardChat || !state.currentForwardMessage) return;
  
  const targetChat = state.chats[selectedForwardChat];
  if (!targetChat) return;

   // Create message with forward metadata
  const forwardMessageText = `[FORWARDED_FROM:${state.currentForwardMessage.sender}] ${state.currentForwardMessage.text}`;
  
  // Create forwarded message in the SAME FORMAT as regular messages
  const message = {
    timestamp: new Date().toISOString(),
    sender: state.currentUser,
    text: forwardMessageText,
    text: state.currentForwardMessage.text, // Keep the original text
    localId: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
    isForwarded: true,
    originalSender: state.currentForwardMessage.sender,
    originalMessage: state.currentForwardMessage.text,
    forwardedAt: new Date().toISOString(),
      sharedId: createSharedMessageId({ // ADD THIS
    timestamp: new Date().toISOString(),
    sender: state.currentUser,
    receiver: targetChat.id === 'Global Chat' ? 'GROUP' : targetChat.id,
    text: state.currentForwardMessage.text
  })
  };
  
  // Add to target chat with proper display text
  const displayMessage = {
    ...message,
    text: `‚Ü™ Forwarded from ${state.currentForwardMessage.sender}: ${state.currentForwardMessage.text}`,
  };
  
  targetChat.messages.push(displayMessage);
  targetChat.lastActivity = message.timestamp;
  
  // Send to backend (use the same format as regular messages)
  const backendMessage = {
    timestamp: message.timestamp,
    sender: state.currentUser,
    receiver: targetChat.id === 'Global Chat' ? 'GROUP' : targetChat.id,
    message: forwardMessageText // Include metadata
  };
  
  // Send to backend
  fetch(scriptUrl, {
    method: 'POST',
    mode: 'no-cors',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(backendMessage)
  }).catch(error => console.error('Error forwarding message:', error));
  
  // Show success
  showToast(`Message forwarded to ${targetChat.name}`, 'success');
  
  // Close modal
  closeMessageActionsModal();
  
  // Update chat cards
  renderChatCards();
}

// Close message actions modal
function closeMessageActionsModal() {
  closeModal('message-actions-modal');
  state.currentForwardMessage = null;
  selectedForwardChat = null;
  state.forwardMode = false;
  document.getElementById('send-forward-btn').disabled = true;
}

// Helper to check if reply can be jumped to
function canJumpToReply(replyMessage, currentChat) {
  if (!replyMessage || !replyMessage.replyTo || !currentChat) return false;
  
  // Reply must be in the same chat
  const isSameChat = replyMessage.replyTo.messageId && 
                    currentChat.messages.some(msg => 
                      msg.localId === replyMessage.replyTo.messageId
                    );
  
  // For group chats, additional checks
  if (currentChat.type === 'group') {
    return isSameChat && 
           (replyMessage.replyTo.sender === state.currentUser || 
            replyMessage.sender === replyMessage.replyTo.sender);
  }
  
  // For individual chats
  return isSameChat;
}

// Helper to find message by content
function findMessageByContent(chat, sender, text) {
  if (!chat || !chat.messages) return null;
  
  // Try exact match first
  for (const msg of chat.messages) {
    if (msg.sender === sender && msg.text === text) {
      return msg;
    }
  }
  
  // Try partial match (first 20 chars)
  const searchText = text.substring(0, Math.min(20, text.length));
  for (const msg of chat.messages) {
    if (msg.sender === sender && msg.text && msg.text.includes(searchText)) {
      return msg;
    }
  }
  
  // Try any message from sender
  for (const msg of chat.messages) {
    if (msg.sender === sender) {
      return msg;
    }
  }
  
  return null;
}

// Create a content-based identifier for replies
function createReplyIdentifier(sender, text) {
  // Create a hash from sender + first 20 chars of text
  const content = sender + ':' + text.substring(0, Math.min(20, text.length));
  let hash = 0;
  for (let i = 0; i < content.length; i++) {
    const char = content.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return 'msg_' + Math.abs(hash).toString(36);
}

// Context menu for links
let currentContextMenuUrl = '';
let currentContextMenuPhone = '';

// Show context menu for links
document.addEventListener('contextmenu', (e) => {
  const clickedElement = e.target;
  
  // Check if clicked on a link or phone number
  if (clickedElement.classList.contains('clickable-link')) {
    e.preventDefault();
    currentContextMenuUrl = clickedElement.textContent;
    showLinkContextMenu(e.clientX, e.clientY);
  } else if (clickedElement.classList.contains('clickable-phone')) {
    e.preventDefault();
    currentContextMenuPhone = clickedElement.textContent;
    showPhoneContextMenu(e.clientX, e.clientY);
  }
});

// Close context menu on click
document.addEventListener('click', () => {
  hideContextMenu();
});

// Show link context menu
function showLinkContextMenu(x, y) {
  hideContextMenu();
  
  const menu = document.createElement('div');
  menu.className = 'link-context-menu';
  menu.id = 'link-context-menu';
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  
  const url = currentContextMenuUrl.startsWith('www.') ? 'https://' + currentContextMenuUrl : currentContextMenuUrl;
  
  menu.innerHTML = `
    <div class="context-menu-item" onclick="copyToClipboard('${escapeHtml(url)}', 'Link')">
      <i class="fas fa-copy"></i>
      <span>Copy Link</span>
    </div>
    <div class="context-menu-item" onclick="openInNewTab('${escapeHtml(url)}')">
      <i class="fas fa-external-link-alt"></i>
      <span>Open in New Tab</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="shareLink('${escapeHtml(url)}')">
      <i class="fas fa-share"></i>
      <span>Share Link</span>
    </div>
  `;
  
  document.body.appendChild(menu);
  menu.classList.add('show');
}

// Show phone context menu
function showPhoneContextMenu(x, y) {
  hideContextMenu();
  
  const menu = document.createElement('div');
  menu.className = 'link-context-menu';
  menu.id = 'phone-context-menu';
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  
  const cleanNumber = currentContextMenuPhone.replace(/[\s\-\(\)]/g, '');
  
  menu.innerHTML = `
    <div class="context-menu-item" onclick="copyToClipboard('${cleanNumber}', 'Phone Number')">
      <i class="fas fa-copy"></i>
      <span>Copy Number</span>
    </div>
    <div class="context-menu-item" onclick="addToContacts('${cleanNumber}')">
      <i class="fas fa-address-book"></i>
      <span>Add to Contacts</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="makePhoneCall('${cleanNumber}')">
      <i class="fas fa-phone"></i>
      <span>Call Now</span>
    </div>
  `;
  
  document.body.appendChild(menu);
  menu.classList.add('show');
}

// Hide context menu
function hideContextMenu() {
  const menu = document.getElementById('link-context-menu');
  const phoneMenu = document.getElementById('phone-context-menu');
  
  if (menu) menu.remove();
  if (phoneMenu) phoneMenu.remove();
}

// Helper functions for context menu
function copyToClipboard(text, label) {
  navigator.clipboard.writeText(text).then(() => {
    showToast(`${label} copied to clipboard`, 'success');
    hideContextMenu();
  }).catch(err => {
    console.error('Failed to copy:', err);
    showToast('Failed to copy', 'error');
  });
}

function openInNewTab(url) {
  proceedToLink(url);
  hideContextMenu();
}

function shareLink(url) {
  if (navigator.share) {
    navigator.share({
      title: 'Check this link',
      url: url
    }).then(() => {
      hideContextMenu();
    }).catch(err => {
      console.error('Share failed:', err);
      copyToClipboard(url, 'Link');
    });
  } else {
    copyToClipboard(url, 'Link');
  }
}

function addToContacts(number) {
  // This would typically open the device's contacts app
  // For now, just copy to clipboard
  copyToClipboard(number, 'Phone Number');
  showToast('Paste the number in your contacts app', 'info');
}

// Apply linkification to all messages in current chat
function applyLinkificationToExistingMessages() {
  if (!state.currentChat || !elements.messagesContainer) return;
  
  const messageElements = elements.messagesContainer.querySelectorAll('.message-text');
  
  messageElements.forEach(element => {
    // Only process if not already linkified (no clickable links inside)
    if (!element.innerHTML.includes('clickable-link') && !element.innerHTML.includes('clickable-phone')) {
      const originalText = element.textContent;
      const linkifiedText = parseAndLinkify(originalText);
      
      // Only update if changes were made
      if (linkifiedText !== escapeHtml(originalText)) {
        element.innerHTML = linkifiedText;
      }
    }
  });
}

// Function to parse and make URLs/phones clickable
function parseAndLinkify(text) {
  if (!text) return '';
  
  // Escape HTML first to prevent XSS
  let safeText = escapeHtml(text);
  
  // Parse URLs (http, https, ftp, www)
  safeText = safeText.replace(
    /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gi,
    '<span class="clickable-link" onclick="handleLinkClick(\'$1\')">$1</span>'
  );
  
  // Parse www links without protocol
  safeText = safeText.replace(
    /(\bwww\.[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gi,
    '<span class="clickable-link" onclick="handleLinkClick(\'https://$1\')">$1</span>'
  );
  
  // Parse email addresses
  safeText = safeText.replace(
    /(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b)/gi,
    '<span class="clickable-link" onclick="handleEmailClick(\'$1\')">$1</span>'
  );
  
  // Parse phone numbers (various international formats)
  safeText = safeText.replace(
    /(\+?[\d\s\-\(\)]{7,}\d)/g,
    function(match) {
      // Clean the phone number for dialing
      const cleanNumber = match.replace(/[\s\-\(\)]/g, '');
      return `<span class="clickable-phone" onclick="handlePhoneClick('${cleanNumber}', '${match}')">${match}</span>`;
    }
  );
  
  return safeText;
}

// Handle URL clicks
function handleLinkClick(url) {
  // Add protocol if missing
  let fullUrl = url;
  if (!url.match(/^https?:\/\//i) && !url.match(/^ftp:\/\//i)) {
    if (url.startsWith('www.')) {
      fullUrl = 'https://' + url;
    } else {
      fullUrl = 'https://' + url;
    }
  }
  
  // Show confirmation for external links
  showLinkConfirmation(fullUrl);
}

// Handle email clicks
function handleEmailClick(email) {
  if (confirm(`Send email to ${email}?`)) {
    window.location.href = `mailto:${email}`;
  }
}

// Handle phone number clicks
function handlePhoneClick(cleanNumber, displayNumber) {
  showPhoneCallConfirmation(cleanNumber, displayNumber);
}

// Show confirmation modal for external links
function showLinkConfirmation(url) {
  const domain = extractDomain(url);
  
  const modalHTML = `
    <div class="modal-overlay active" id="link-confirmation-modal">
      <div class="modal-content">
        <h2 class="modal-title">Open External Link</h2>
        
        <div class="external-link-warning">
          <i class="fas fa-external-link-alt"></i>
          You are about to open an external website
        </div>
        
        <p style="margin: 15px 0; word-break: break-all; color: var(--text-secondary);">
          ${url}
        </p>
        
        <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 20px;">
          Domain: ${domain}
        </p>
        
        <div class="modal-actions">
          <button class="modal-btn secondary" onclick="closeLinkConfirmation()">
            Cancel
          </button>
          <button class="modal-btn primary" onclick="proceedToLink('${escapeHtml(url)}')">
            Open Link
          </button>
        </div>
      </div>
    </div>
  `;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer);
}

// Show phone call confirmation modal
function showPhoneCallConfirmation(cleanNumber, displayNumber) {
  const modalHTML = `
    <div class="modal-overlay active" id="phone-confirmation-modal">
      <div class="modal-content phone-call-modal">
        <i class="fas fa-phone-alt"></i>
        <h2 class="modal-title">Call Phone Number</h2>
        
        <div class="phone-number-display">
          ${displayNumber}
        </div>
        
        <p style="margin-bottom: 20px; color: var(--text-secondary);">
          Do you want to call this number?
        </p>
        
        <div class="modal-actions">
          <button class="modal-btn secondary" onclick="closePhoneConfirmation()">
            Cancel
          </button>
          <button class="modal-btn primary" onclick="makePhoneCall('${cleanNumber}')">
            <i class="fas fa-phone" style="margin-right: 8px;"></i>
            Call Now
          </button>
        </div>
      </div>
    </div>
  `;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer);
}

// Extract domain from URL
function extractDomain(url) {
  try {
    const urlObj = new URL(url.startsWith('http') ? url : 'https://' + url);
    return urlObj.hostname;
  } catch (e) {
    return url;
  }
}

// Proceed to open link
function proceedToLink(url) {
  closeLinkConfirmation();
  window.open(url, '_blank', 'noopener,noreferrer');
}

// Make phone call
function makePhoneCall(number) {
  closePhoneConfirmation();
  window.location.href = `tel:${number}`;
}

// Close modals
function closeLinkConfirmation() {
  const modal = document.getElementById('link-confirmation-modal');
  if (modal) modal.remove();
}

function closePhoneConfirmation() {
  const modal = document.getElementById('phone-confirmation-modal');
  if (modal) modal.remove();
}

// Close modals when clicking outside
document.addEventListener('click', (e) => {
  if (e.target.classList.contains('modal-overlay')) {
    if (e.target.id === 'link-confirmation-modal') {
      closeLinkConfirmation();
    } else if (e.target.id === 'phone-confirmation-modal') {
      closePhoneConfirmation();
    }
  }
});

// ========== MESSAGE REACTIONS FUNCTIONS ==========

// Initialize reactions for a message
function initializeMessageReactions(message) {
  if (!message.reactions) {
    message.reactions = {};
  }
  
  // Initialize each reaction type
  Object.keys(REACTIONS).forEach(emoji => {
    if (!message.reactions[emoji]) {
      message.reactions[emoji] = {
        count: 0,
        users: []
      };
    }
  });
  
  return message;
}

// Add reaction to a message
function addReaction(messageId, emoji, username) {
  const currentChat = state.chats[state.currentChat];
  if (!currentChat) return;
  
  const message = currentChat.messages.find(msg => msg.localId === messageId);
  if (!message) return;
  
  // Ensure reactions object exists
  message.reactions = message.reactions || {};
  
  // Initialize this emoji if not exists
  if (!message.reactions[emoji]) {
    message.reactions[emoji] = {
      count: 0,
      users: []
    };
  }
  
  const reaction = message.reactions[emoji];
  
  // Check if user already reacted with this emoji
  const userIndex = reaction.users.indexOf(username);
  let action = 'add'; // Track whether we're adding or removing
  
  if (userIndex > -1) {
    // Remove reaction
    reaction.users.splice(userIndex, 1);
    reaction.count--;
    action = 'remove';
    
    if (reaction.count === 0) {
      delete message.reactions[emoji];
    }
    
    showToast(`Removed ${emoji} reaction`, 'info');
  } else {
    // Add reaction
    reaction.users.push(username);
    reaction.count++;
    action = 'add';
    
    showToast(`Reacted with ${emoji}`, 'success');
  }

  // Send reaction to Google Sheets for sync
  sendReactionToBackend(messageId, emoji, username, action);
  
  // Update the message in state
  const messageIndex = currentChat.messages.findIndex(msg => msg.localId === messageId);
  if (messageIndex > -1) {
    currentChat.messages[messageIndex] = { ...message };
  }
  
  // Update UI
  loadChatMessages();
  
  // Save reaction to localStorage for persistence
  saveMessageReactions(messageId, message.reactions);
}

// Save reactions to localStorage
function saveMessageReactions(messageId, reactions) {
  const key = `chatApp_reactions_${messageId}`;
  localStorage.setItem(key, JSON.stringify(reactions));
}

// Send reaction to Google Sheets
// Send reaction to Google Sheets
function sendReactionToBackend(messageId, emoji, username, action) {
  const currentChat = state.chats[state.currentChat];
  if (!currentChat) return;
  
  const message = currentChat.messages.find(msg => msg.localId === messageId);
  if (!message) {
    console.log('‚ùå Message not found for reaction:', messageId);
    return;
  }
  
  // Use sharedId if available, otherwise use localId
  const targetId = message.sharedId || messageId;
  console.log('üì§ Sending reaction with target ID:', targetId);
  
  // Format: [REACTION:targetId:emoji:username:action]
  const reactionMessage = `[REACTION:${targetId}:${emoji}:${username}:${action}]`;
  
  const backendMessage = {
    timestamp: new Date().toISOString(),
    sender: username,
    receiver: state.currentChat === 'Global Chat' ? 'GROUP' : state.currentChat,
    message: reactionMessage
  };
  
  console.log('üì§ Reaction payload:', backendMessage);
  
  // Send to Google Sheets
  fetch(scriptUrl, {
    method: 'POST',
    mode: 'no-cors',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(backendMessage)
  }).then(() => {
    console.log('‚úÖ Reaction sent to backend:', reactionMessage);
  }).catch(error => {
    console.error('‚ùå Error sending reaction:', error);
    showToast('Failed to sync reaction', 'error');
  });
}

// Load reactions from localStorage
function loadMessageReactions(messageId) {
  const key = `chatApp_reactions_${messageId}`;
  const saved = localStorage.getItem(key);
  return saved ? JSON.parse(saved) : null;
}

// Toggle reaction picker
function toggleReactionPicker(messageId, element) {
  const picker = document.getElementById(`reaction-picker-${messageId}`);
  
  if (picker && picker.classList.contains('show')) {
    picker.classList.remove('show');
  } else {
    // Close any other open pickers
    document.querySelectorAll('.reaction-picker.show').forEach(p => {
      p.classList.remove('show');
    });
    
    // Create or show picker
    showReactionPicker(messageId, element);
  }
}

// Show reaction picker
function showReactionPicker(messageId, triggerElement) {
  // Remove existing picker
  const existingPicker = document.getElementById(`reaction-picker-${messageId}`);
  if (existingPicker) {
    existingPicker.remove();
  }
  
  // Get position for picker
  const rect = triggerElement.getBoundingClientRect();
  
  // Create picker
  const picker = document.createElement('div');
  picker.id = `reaction-picker-${messageId}`;
  picker.className = 'reaction-picker';
  
  // Add reaction options
  let pickerHTML = '';
  Object.keys(REACTIONS).forEach(emoji => {
    pickerHTML += `<div class="reaction-option" onclick="addReaction('${messageId}', '${emoji}', '${state.currentUser}')">${emoji}</div>`;
  });
  
  picker.innerHTML = pickerHTML;
  document.body.appendChild(picker);
  
  // Position picker
  const pickerWidth = picker.offsetWidth;
  const pickerHeight = picker.offsetHeight;
  
  let left = rect.left + (rect.width / 2) - (pickerWidth / 2);
  let top = rect.top - pickerHeight - 10;
  
  // Adjust if near screen edges
  if (left < 10) left = 10;
  if (left + pickerWidth > window.innerWidth - 10) {
    left = window.innerWidth - pickerWidth - 10;
  }
  if (top < 10) top = rect.bottom + 10;
  
  picker.style.left = `${left}px`;
  picker.style.top = `${top}px`;
  
  // Show with animation
  setTimeout(() => {
    picker.classList.add('show');
  }, 10);
  
  // Close picker when clicking outside
  setTimeout(() => {
    const closePicker = (e) => {
      if (!picker.contains(e.target) && e.target !== triggerElement) {
        picker.classList.remove('show');
        document.removeEventListener('click', closePicker);
        setTimeout(() => {
          if (picker.parentNode) {
            picker.remove();
          }
        }, 300);
      }
    };
    document.addEventListener('click', closePicker);
  }, 100);
}

// Create reaction element for a message
function createReactionElement(message) {
  if (!message.reactions || Object.keys(message.reactions).length === 0) {
    return '';
  }
  
  // Filter reactions with count > 0
  const activeReactions = Object.entries(message.reactions)
    .filter(([emoji, data]) => data.count > 0)
    .sort((a, b) => b[1].count - a[1].count);
  
  if (activeReactions.length === 0) {
    return '';
  }
  
  let reactionsHTML = '<div class="message-reactions">';
  
  activeReactions.forEach(([emoji, data]) => {
    const isUserReacted = data.users.includes(state.currentUser);
    const reactionClass = `reaction ${isUserReacted ? 'active' : ''}`;
    const userList = data.users.join(', ');
    
      reactionsHTML += `
      <div class="${reactionClass}" 
           onclick="addReaction('${message.localId}', '${emoji}', '${state.currentUser}')" 
           oncontextmenu="event.preventDefault(); showReactionDetails('${message.localId}', '${emoji}')"
           title="${userList} reacted with ${emoji}">
        <span class="reaction-emoji">${emoji}</span>
        <span class="reaction-count">${data.count}</span>
      </div>
    `;
  });
  
  reactionsHTML += '</div>';
  return reactionsHTML;
}

// Create a shared message ID that works across all users
function createSharedMessageId(message) {
  // Clean the text for consistent hashing
  const cleanText = (message.text || '').trim().substring(0, 50);
  const cleanSender = (message.sender || '').trim();
  const cleanReceiver = (message.receiver || '').trim();
  const cleanTimestamp = (message.timestamp || '').split('.')[0]; // Remove milliseconds
  
  // Create a consistent string for hashing
  const hashString = `${cleanTimestamp}:${cleanSender}:${cleanReceiver}:${cleanText}`;
  
  // Simple hash function
  let hash = 0;
  for (let i = 0; i < hashString.length; i++) {
    const char = hashString.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  return `shared_${Math.abs(hash).toString(36)}`;
}

// Show reaction details
function showReactionDetails(messageId, emoji) {
  const currentChat = state.chats[state.currentChat];
  if (!currentChat) return;
  
  const message = currentChat.messages.find(msg => msg.localId === messageId);
  if (!message || !message.reactions || !message.reactions[emoji]) return;
  
  const reaction = message.reactions[emoji];
  
  const modalHTML = `
    <div class="modal-overlay active" id="reaction-details-modal">
      <div class="modal-content reaction-details-modal">
        <h2 class="modal-title" style="display: flex; align-items: center; gap: 10px;">
          <span>${emoji}</span>
          <span>${REACTIONS[emoji].name}</span>
        </h2>
        
        <div style="margin: 15px 0; text-align: center;">
          <div style="font-size: 48px; margin-bottom: 10px;">${emoji}</div>
          <div style="color: var(--text-secondary);">
            ${reaction.count} reaction${reaction.count !== 1 ? 's' : ''}
          </div>
        </div>
        
        <div style="max-height: 300px; overflow-y: auto;">
          ${reaction.users.map(user => `
            <div class="reaction-detail-item">
              <div class="reaction-detail-left">
                <div class="profile-avatar small" style="background: ${getColorFromString(user)}; width: 36px; height: 36px;">
                  ${getInitials(user)}
                </div>
                <div>
                  <div class="reaction-detail-name">${user}</div>
                  <div class="reaction-detail-time">Reacted with ${emoji}</div>
                </div>
              </div>
              ${user === state.currentUser ? 
                '<button class="unblock-btn" onclick="removeOwnReaction(\'' + messageId + '\', \'' + emoji + '\')">Remove</button>' : 
                ''
              }
            </div>
          `).join('')}
        </div>
        
        <div class="modal-actions">
          <button class="modal-btn primary" onclick="closeReactionDetails()">
            Close
          </button>
        </div>
      </div>
    </div>
  `;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer);
}

// Remove own reaction from details view
function removeOwnReaction(messageId, emoji) {
  addReaction(messageId, emoji, state.currentUser);
  closeReactionDetails();
  setTimeout(() => {
    showReactionDetails(messageId, emoji);
  }, 100);
}

// Close reaction details modal
function closeReactionDetails() {
  const modal = document.getElementById('reaction-details-modal');
  if (modal) modal.remove();
}

// Load saved reactions when loading messages
function loadSavedReactions(message) {
  if (!message.localId) return message;
  
  const savedReactions = loadMessageReactions(message.localId);
  if (savedReactions) {
    message.reactions = { ...savedReactions };
  }
  
  return message;
}

// Process incoming reactions from other users
// Process incoming reactions from other users
function processIncomingReaction(targetMessageId, emoji, reactingUser, action, timestamp) {
  console.log('üîç Processing incoming reaction:', { targetMessageId, emoji, reactingUser, action });
  debugReaction(targetMessageId, emoji, reactingUser, action);
  
  // First, check if targetMessageId is a sharedId (starts with "shared_")
  const isSharedId = targetMessageId.startsWith('shared_');
  
  let targetChat = null;
  let targetMessage = null;
  
  // Search through all chats
  for (const chatId in state.chats) {
    const chat = state.chats[chatId];
    if (!chat.messages) continue;
    
    // Try to find the message
    const foundMessage = chat.messages.find(msg => {
      if (isSharedId) {
        // Look for sharedId match
        return msg.sharedId === targetMessageId;
      } else {
        // Look for localId match (fallback)
        return msg.localId === targetMessageId;
      }
    });
    
    if (foundMessage) {
      targetChat = chat;
      targetMessage = foundMessage;
      console.log('‚úÖ Found target message:', targetMessage.text.substring(0, 50));
      break;
    }
  }
  
  // If not found by ID, try to find by content (emergency fallback)
  if (!targetMessage) {
    console.log('‚ö†Ô∏è Message not found by ID, trying content matching...');
    
    // Extract possible message text from the sharedId or look for recent messages
    for (const chatId in state.chats) {
      const chat = state.chats[chatId];
      if (!chat.messages) continue;
      
      // Get most recent messages (last 20)
      const recentMessages = [...chat.messages]
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 20);
      
      for (const msg of recentMessages) {
        // Check if message is from a similar time (within 5 minutes)
        const reactionTime = new Date(timestamp);
        const messageTime = new Date(msg.timestamp);
        const timeDiff = Math.abs(reactionTime - messageTime);
        
        if (timeDiff < 300000) { // 5 minutes
          targetChat = chat;
          targetMessage = msg;
          console.log('‚úÖ Found recent message as fallback');
          break;
        }
      }
      
      if (targetMessage) break;
    }
  }
  
  if (!targetChat || !targetMessage) {
    console.log('‚ùå Could not find target message for reaction');
    showToast(`Reaction from ${reactingUser} could not be applied`, 'warning');
    return;
  }
  
  // Ensure reactions object exists
  targetMessage.reactions = targetMessage.reactions || {};
  
  // Initialize this emoji if not exists
  if (!targetMessage.reactions[emoji]) {
    targetMessage.reactions[emoji] = {
      count: 0,
      users: []
    };
  }
  
  const reaction = targetMessage.reactions[emoji];
  
  if (action === 'add') {
    // Add reaction if not already present
    if (!reaction.users.includes(reactingUser)) {
      reaction.users.push(reactingUser);
      reaction.count++;
      console.log(`‚úÖ Added ${emoji} from ${reactingUser}`);
      
      // Show notification for reactions to your messages
      if (targetMessage.sender === state.currentUser && reactingUser !== state.currentUser) {
        showToast(`${reactingUser} reacted ${emoji} to your message`, 'info');
      }
    }
  } else if (action === 'remove') {
    // Remove reaction
    const userIndex = reaction.users.indexOf(reactingUser);
    if (userIndex > -1) {
      reaction.users.splice(userIndex, 1);
      reaction.count--;
      console.log(`‚úÖ Removed ${emoji} from ${reactingUser}`);
      
      if (reaction.count === 0) {
        delete targetMessage.reactions[emoji];
      }
    }
  }
  
  // Update the message in the chat array
  const messageIndex = targetChat.messages.findIndex(msg => 
    msg.localId === targetMessage.localId
  );
  
  if (messageIndex > -1) {
    targetChat.messages[messageIndex] = { ...targetMessage };
  }
  
  // Save to localStorage
  saveMessageReactions(targetMessage.localId, targetMessage.reactions);
  
  // Update UI if we're currently viewing this chat
  if (state.currentChat === targetChat.id) {
    console.log('üîÑ Reloading messages for current chat');
    loadChatMessages();
  }
  
  // Update chat cards
  renderChatCards();
  
  console.log('‚úÖ Reaction processed successfully');
}

// Helper to find a message by ID across all chats
function findMessageById(messageId) {
  for (const chatId in state.chats) {
    const chat = state.chats[chatId];
    if (chat.messages) {
      const message = chat.messages.find(msg => msg.localId === messageId);
      if (message) {
        return { chat, message, chatId };
      }
    }
  }
  return null;
}

// Load reactions from existing messages in Google Sheets data
function loadReactionsFromExistingMessages() {
  // This would be called after loading initial messages
  // It would parse all existing messages for reaction data
  
  // For now, we'll rely on the polling to catch up
  // In a production app, you might want to parse all historical messages
  console.log('Reaction system initialized');
}

// Assign shared IDs to existing messages
function assignSharedIdsToExistingMessages() {
  for (const chatId in state.chats) {
    const chat = state.chats[chatId];
    if (chat.messages) {
      chat.messages.forEach(msg => {
        if (!msg.sharedId) {
          msg.sharedId = createSharedMessageId({
            timestamp: msg.timestamp,
            sender: msg.sender,
            receiver: msg.receiver || chatId,
            text: msg.text
          });
        }
      });
    }
  }
}

// Debug function for reactions
function debugReaction(targetMessageId, emoji, reactingUser, action) {
  console.log('=== REACTION DEBUG ===');
  console.log('Target Message ID:', targetMessageId);
  console.log('Emoji:', emoji);
  console.log('User:', reactingUser);
  console.log('Action:', action);
  
  // Log all messages with their IDs
  for (const chatId in state.chats) {
    const chat = state.chats[chatId];
    if (chat.messages) {
      console.log(`Chat: ${chatId}`);
      chat.messages.forEach((msg, index) => {
        console.log(`  [${index}] localId: ${msg.localId}, sharedId: ${msg.sharedId}, text: ${msg.text.substring(0, 30)}...`);
      });
    }
  }
  console.log('======================');
}

// Test function to verify reaction system
function testReactionSystem() {
  console.log('üß™ Testing reaction system...');
  
  if (!state.currentChat || !state.currentUser) {
    console.log('‚ùå No chat or user selected');
    return;
  }
  
  const currentChat = state.chats[state.currentChat];
  if (!currentChat.messages || currentChat.messages.length === 0) {
    console.log('‚ùå No messages in current chat');
    return;
  }
  
  // Get the latest message
  const latestMessage = currentChat.messages[currentChat.messages.length - 1];
  console.log('üìù Latest message:', latestMessage.text.substring(0, 50));
  console.log('üîë Message IDs - localId:', latestMessage.localId, 'sharedId:', latestMessage.sharedId);
  
  // Test adding a reaction
  console.log('üß™ Testing reaction addition...');
  addReaction(latestMessage.localId, 'üëç', state.currentUser);
}

// Check for reaction sync issues
function checkReactionSync() {
  console.log('üîÑ Checking reaction sync...');
  
  // Log reaction counts for debugging
  for (const chatId in state.chats) {
    const chat = state.chats[chatId];
    if (chat.messages) {
      let reactionCount = 0;
      chat.messages.forEach(msg => {
        if (msg.reactions) {
          Object.values(msg.reactions).forEach(reaction => {
            reactionCount += reaction.count;
          });
        }
      });
      
      if (reactionCount > 0) {
        console.log(`üí¨ Chat ${chatId}: ${reactionCount} total reactions`);
      }
    }
  }
}

// Call this every 30 seconds
setInterval(checkReactionSync, 30000);

// ========== UNREAD MESSAGE MANAGEMENT ==========

// Get last read timestamp for a chat
function getLastReadTimestamp(chatId) {
  const key = `chatApp_lastRead_${chatId}`;
  const timestamp = localStorage.getItem(key);
  return timestamp ? parseInt(timestamp) : 0; // 0 = never read
}

// Set last read timestamp for a chat
function setLastReadTimestamp(chatId) {
  const key = `chatApp_lastRead_${chatId}`;
  const timestamp = Date.now();
  localStorage.setItem(key, timestamp.toString());
  return timestamp;
}

// Calculate unread count for a chat
function calculateUnreadCount(chat) {
  if (!chat || !chat.messages || chat.messages.length === 0) {
    return 0;
  }
  
  const lastReadTimestamp = getLastReadTimestamp(chat.id);
  const currentUser = state.currentUser;
  
  // Count messages from others that are newer than last read timestamp
  let unreadCount = 0;
  
  for (const message of chat.messages) {
    // Skip messages from current user
    if (message.sender === currentUser) continue;
    
    // Skip reaction messages
    if (message.isReactionMessage) continue;
    
    const messageTime = new Date(message.timestamp).getTime();
    
    // Message is unread if it's newer than last read timestamp
    if (messageTime > lastReadTimestamp) {
      unreadCount++;
    }
  }
  
  return unreadCount;
}

// Update all chat unread counts
function updateAllUnreadCounts() {
  for (const chatId in state.chats) {
    const chat = state.chats[chatId];
    chat.unread = calculateUnreadCount(chat);
  }
  renderChatCards();
}

// Mark all messages in a chat as read
function markChatAsRead(chatId) {
  setLastReadTimestamp(chatId);
  const chat = state.chats[chatId];
  if (chat) {
    chat.unread = 0;
  }
  
  // Update UI
  document.querySelectorAll(`.chat-card[data-chat-id="${chatId}"]`).forEach(card => {
    card.classList.remove('has-unread');
    const badge = card.querySelector('.chat-card-badge');
    if (badge) badge.remove();
  });
  
  updateRequestsBadge();
  checkNotifications();
}

// Handle new chat creation (for message requests, new contacts, etc.)
function handleNewChat(chatId, initialMessage = null) {
  const chat = state.chats[chatId];
  if (!chat) return;
  
  // For new chats, set last read timestamp to before the first message
  if (initialMessage && initialMessage.timestamp) {
    const messageTime = new Date(initialMessage.timestamp).getTime();
    // Set last read to 1 second before the message
    const key = `chatApp_lastRead_${chatId}`;
    localStorage.setItem(key, (messageTime - 1000).toString());
  } else {
    // For completely new chats with no messages yet, mark as read
    setLastReadTimestamp(chatId);
  }
  
  // Calculate unread count
  chat.unread = calculateUnreadCount(chat);
  
  // Update UI
  renderChatCards();
}

// Mark all chats as read
function markAllAsRead() {
  for (const chatId in state.chats) {
    markChatAsRead(chatId);
  }
  
  showToast('All messages marked as read', 'success');
  updateAllUnreadCounts();
}

// Add to UI (optional - add a button somewhere)
function addMarkAllReadButton() {
  const button = document.createElement('button');
  button.innerHTML = '<i class="fas fa-check-double"></i> Mark All Read';
  button.style.position = 'fixed';
  button.style.bottom = '20px';
  button.style.right = '20px';
  button.style.zIndex = '999';
  button.style.padding = '10px 15px';
  button.style.background = 'var(--primary-color)';
  button.style.color = 'white';
  button.style.border = 'none';
  button.style.borderRadius = '20px';
  button.style.cursor = 'pointer';
  button.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
  button.onclick = markAllAsRead;
  document.body.appendChild(button);
}

// Call in initializeApp()
// addMarkAllReadButton(); // Uncomment if you want this button
  </script>
</body>
</html>
